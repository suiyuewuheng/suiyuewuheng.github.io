<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis-first blood]]></title>
    <url>%2F2018%2F09%2F28%2Fredis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[#### Nosql 非关系型数据库NoSQL=Not only SQL 关系型数据库劣势： 高并发读写（因为关系型数据库表和表之间存在关系，耦合性大。查询一次可能会查询到其他不需要的数据，造成性能浪费，关系型数据库数据保存在DISK中，像Redis这种数据库，数据是保存在内存之中的 ） 海量数据的高效率存储和访问 高可扩展性和高可用性（无法通过增加硬件来增加容量，升级扩展往往需要停机） NoSQL非关系数据库（redis mongodb） 优点： 去掉了关系数据库的”关系特性” 易扩展 有非常高的读写性能 尤其在大数据量下 灵活的数据模型（无需提前简历字段） 高可用 缺点: 没有统一的标准 层出不穷 NoSQL四大分类： 一、键值对存储 =&gt;redis优势：查找速度比较快劣势：存储数据缺少结构化 二、列存储优势：查找速度比较快 扩展性强劣势：功能比较局限性 三、文档数据库 =&gt;MongoDB优势：数据结构要求不严格劣势：查询性能不是特别的高 四、图形数据库 =&gt;应用于社交网络的数据库优势：图结构的算法劣势：不容易分布式集群方案 redis概述 redis c语言开发的非关系型数据库，起初是来源于一个mysql的项目，是一个高性能的键值对数据库，redis读的次数每秒钟11万次写的速度达到每秒8.1万次。 支持的键值数据类型： 字符串类型 列表类型 有序集合烈性 散列类型 集合类型 redis应用场景： 缓存（提供缓存服务，存储访问频率高的热数据防止穿透到数据库） 任务队列（一般做抢购、秒杀 等，聊天室） 网站访问的统计 数据过期处理（可以精确到毫秒） 应用的排行榜 分布式集群架构中的session分离 redis安装 下载地址:https://redis.io wget http://download.redis.io/releases/redis-4.0.11.tar.gztar -zxvf redis-4.0.11.tar.gzmakemake PREFIX=/usr/local/redis installcp redis.conf /usr/local/redis/ 123456ls -l /usr/local/redis/bin/ redis-benchmark ---性能测试工具 redis-check-aof ---aof修复工具 redis-check-dump ---rdb 文件检查工具 redis-cli ---命令行客户端 redis-server ----redis服务器启动命令 12345678910111213141516171819202122232425262728293031启动: sed &apos;s/daemonize no/daemonize yes/&apos; -i redis.conf ./bin/redis-server ./redis.conf 以上两步为的是启动方式不是前端启动，使得当前终端还可以使用[root@redis redis]# ps -ef |grep redisroot 8879 1 0 15:48 ? 00:00:00 ./bin/redis-server 127.0.0.1:6379root 8928 1784 0 15:52 pts/0 00:00:00 grep redis[root@redis redis]# 停止:./bin/redis-cli shutdownredis初体验:[root@redis redis]# ./bin/redis-cli 127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set name Tom //键值对OK127.0.0.1:6379&gt; get name&quot;Tom&quot;127.0.0.1:6379&gt; keys * //查看所有键1) &quot;name&quot;127.0.0.1:6379&gt; del name(integer) 1127.0.0.1:6379&gt; get name(nil)127.0.0.1:6379&gt; keys(error) ERR wrong number of arguments for &apos;keys&apos; command127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mysql物语-配置基础]]></title>
    <url>%2F2018%2F09%2F28%2Fmysql%E7%89%A9%E8%AF%AD-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[配置文件 查看配置文件读取顺序:mysqld –help –verbose |grep .cnf1234[root@none /]# /usr/libexec/mysqld --help --verbose |grep .cnf/etc/mysql/my.cnf /etc/my.cnf ~/.my.cnf order of preference, my.cnf, $MYSQL_TCP_PORT,[root@none /]# 可以看到这是Mysql默认的配置文件读取顺序（centos6.5）.而在MariaDB中，则是:12mysqld --help --verbose |grep .cnf/etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf ++由于配置文件的读取顺序不同，所以在配置项参数时，要注意先后是否覆盖。++ mysql客户端配置:123456789101112vim /etc/my.cnf在原来的基础上添加下列语句，表示客户端的设置。其中[client]管理所有客户端工具，包括mysql和mysqladmin，如果注释掉[client]，则后面的各自独立，互不影响。,下面配置作用是mysqldmain工具不需要用户密码，如果去掉[client]的注释，则所有客户端都不要用户密码,包括Mysql.[client]#user=root#password=redhat[mysqladmin]user=rootpassword=redhat如测试:mysqladmin shutdown 不需要密码便可关闭数据库mysqladmin ping 查看数据库是否在运行 读取其它配置文件 命令行mysql –defaults-file=~other_host.cnf如:mysql –defaults-file=./your.cnfmysql –defaults_extra-file=file_name 123456789[root@none /]# /usr/libexec/mysqld --help -v |grep defaults--print-defaults Print the program argument list and exit.--no-defaults Don&apos;t read default options from any option file.--defaults-file=# Only read default options from the given file #.--defaults-extra-file=# Read this file after the global files are read.[root@none /]# cp /etc/my.cnf ./your.cnf[root@none /]# /usr/libexec/mysqld --defaults-file=./your.cnf --user=root //在debain上是mysqld --defaults-file=./your.cnf --user=root include !include file_name !includedir dir_name 找dir_name下的后缀是*.cnf的文件[root@two /]# tail -n2 /etc/my.cnf!includedir /etc/my.cnf.d 在mysql中也能进行一些算术运算:12345678910111213141516171819202122232425262728MariaDB [(none)]&gt; select 2+1 -&gt; ;+-----+| 2+1 |+-----+| 3 |+-----+1 row in set (0.00 sec)MariaDB [(none)]&gt; select 2+1;+-----+| 2+1 |+-----+| 3 |+-----+1 row in set (0.00 sec)MariaDB [(none)]&gt; select 8*1024*1024;;+-------------+| 8*1024*1024 |+-------------+| 8388608 |+-------------+1 row in set (0.00 sec)ERROR: No query specifiedMariaDB [(none)]&gt; sql_mode sql_mode主要用来对sql语法格式进行规定和限制12345678910查看默认值MariaDB [(none)]&gt; show variables like &apos;sql_m%&apos;;+---------------+-------------------------------------------------------------------------------------------+| Variable_name | Value |+---------------+-------------------------------------------------------------------------------------------+| sql_mode | STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |+---------------+-------------------------------------------------------------------------------------------+1 row in set (0.00 sec)MariaDB [(none)]&gt; 如果想要修改语法，则:123vim /etc/my.cnf[mysqld]sql_mode=TRADITIONAL 一些默认值释义如下: NO_AUTO_CREATE_USER：禁止GRANT创建密码为空的用户 NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 STRICT_TRANS_TABLES模式：严格模式，进行数据的严格校验，错误数据不能插入，报error错误。 ANSI模式：宽松模式，对插入数据进行校验，如果不符合定义类型或长度，对数据类型调整或截断保存，报warning警告 NO_ZERO_IN_DATE：在严格模式下，不允许日期和月份为零 NO_ZERO_DATE：设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。 ERROR_FOR_DIVISION_BY_ZERO：在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL NO_AUTO_CREATE_USER：禁止GRANT创建密码为空的用户]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ansible-yum包管理]]></title>
    <url>%2F2018%2F09%2F28%2Fansible-yum%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[配置安装apache服务1234567891011121314151617181920212223242526---- name: manage apache hosts: test tasks: - name: install/remove apache yum: name: &quot;&#123;&#123; item &#125;&#125;&quot; state: present with_items: - httpd - httpd-manual - httpd-tools - name: template: //template使用了Jinjia2格式作为文件模版，进行文档内变量的替换的模块。它的每次使用都会被ansible标记为”changed”状态。 src: ./conf.d/httpd.conf.j2 dest: /etc/httpd/conf/httpd.conf backup: yes notify: restart apache handlers: - name: restart apache service: name: httpd state: restarted enabled: yes 移除apacheansible test -m yum -a ‘name=httpd state=removed’ handlers是另一种“任务列表”,handlers中的任务会被tasks中的任务调用，但是被调用并不一定会执行，只有当tasks中的任务“真正执行”以后，也就是造成了实际的改变，也就是没有发生幂等性，handlers中的任务才会被执行，如果tasks中的任务并没有做出实际的操作，那么handlers中的任务别调用也不会执行。在所有tasks任务执行完毕后，才会执行各个hangler 安装apache并下载文件测试1234567891011121314151617181920212223242526272829303132333435- name: manage apache hosts: test tasks: - name: install/remove apache yum: name: &quot;&#123;&#123; item &#125;&#125;&quot; state: present with_items: - httpd - httpd-manual - httpd-tools - name: template: src: ./conf.d/httpd.conf.j2 dest: /etc/httpd/conf/httpd.conf backup: yes force: yes - name: copy: src: /etc/passwd dest: /var/www/html/passwd.&#123;&#123; ansible_hostname &#125;&#125; - name: restart apache service: name: httpd state: restarted enabled: yes - name: test download passwd file from localhost get_url: dest: /tmp/passwd.&#123;&#123; ansible_hostname &#125;&#125; //下载位置，绝对路劲 url: http://&#123;&#123; ansible_eth0.ipv4.address &#125;&#125;/passwd.&#123;&#123; ansible_hostname &#125;&#125; delegate_to: localhost //在控制主机上执行 安装mysql-server并且设置数据缓冲区大小是系统物理内存的一半123456789101112131415161718192021222324252627282930313233343536编辑:playbook文件vim mysql.yaml---- name: install mysql hosts: test tasks: - name: start install mysql-server yum: name: mysql-server state: present - name: set innodb-buffer-pool-size = system-mem/2 set_fact: innodb_buffer_pool_size_mb : &quot;&#123;&#123; ansible_memtotal_mb/2 &#125;&#125;&quot; //注意这里格式分行写中间是冒号:，如果写在一行则是等于= - name: replace my.cnf from templete //替换配置文件 template: src: ./conf.d/my.cnf.j2 dest: /etc/my.cnf mode: 600 - name: initial database //初始化数据库 command: mysql_install_db --user=mysql notify: restart mysql //调用handlers任务 handlers: - name: restart mysql service: name: mysqld state: restarted enabled: yes 出错借助:/usr/libexec/mysqld -v查看 1234567891011121314151617编辑my.cnf.j2配置文件cp my.cnf my.cnf.j2vim my.cnf.j2# &#123;&#123; ansible_managed &#125;&#125; //表明支持下面变量，必加[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0innodb-buffer-pool-size=&#123;&#123; innodb_buffer_pool_size_mb|int &#125;&#125;M[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 12345678910111213141516171819202122登录mysql验证:mysql&gt; show variables like &apos;innodb_bu%&apos; -&gt; ;+-------------------------+-----------+| Variable_name | Value |+-------------------------+-----------+| innodb_buffer_pool_size | 513802240 |+-------------------------+-----------+1 row in set (0.00 sec)mysql&gt; select 513802240 /1024 / 1024 -&gt; ;+------------------------+| 513802240 /1024 / 1024 |+------------------------+| 490.00000000 |+------------------------+1 row in set (0.00 sec)mysql&gt; 我们可以通过ansible的setup得出系统内存是1G，mysql安装完成后，可以看出数据缓冲区的大小是系统物理内存的一半，ansible安装配置mysql完成]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ansible-first blood]]></title>
    <url>%2F2018%2F09%2F28%2Fansible-%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[ansible 简介12345ansible官方的title是“Ansible is Simple IT Automation”——简单的自动化IT工具。这个工具的目标有这么几项：自动化部署APP；自动化管理配置项；自动化的持续交付；自动化的（AWS）云服务管理。所有的这几个目标本质上来说都是在一个台或者几台服务器上，执行一系列的命令而已，而如果你要管理的服务器是成千上万台的，那你用一台服务器去管理控制这大批量的服务器，势必会造成这台主控机的相当可观的资源消耗和性能的低下（即使可以使用 ansible -f 参数并行执行），这时就需要有种 p2p 的概念，让每一台被同步、配置的服务器也可以做为一台 ansible 中控机去同步配置其它的服务器。Ansible 无需安装服务端和客户端，只要 SSH 即可。这意 味着，任何一台装有 Ansible 的机器都可以成为强大的管理端。Ansible 上手十分快，用 Ad-Hoc 可以应付简单的管理任务，麻烦点的也可以定义 Playbook 文 件来搞定。 ansible的特点（1） No agents：不需要在被管控主机上安装任意客户端； （2） No server：无服务器端，使用时直接运行命令即可； （3） Modules in any languages：基于模块工作，可使用任意语言开发模块 （4） YAML，not code：使用yaml语言定制剧本playbook； （5） SSH by default：基于SSH工作； （6） Strong multi-tier solution：可实现多级指挥； 安装方式一: 参考:https://www.centos.bz/2017/07/centos-6-5-ansible-intro/安装epel 源：rpm -ivh https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm或者yum install epel-release -y 安装ansible 服务端：yum install ansible -y 方式二: yum install python-pippip install ansible | pip install ansible==2.4 ansible使用格式1234567891011ansible &lt;host-pattern&gt; [-f forks] [-m module_name] [-a args] host-pattern # 可以是all，或者配置文件中的主机组名 -f forks # 指定并行处理的进程数 -m module # 指定使用的模块，默认模块为command -a args # 指定模块的参数如果你有多台服务器的话，想并发运行，可以使用-f参数，默认是并发5ansible-doc [options] [modules] ：Show Ansible module documentation -l 列出所有的ansible模块 -s 列出该模块的相关指令 ansible是基于paramiko 开发的，paramiko是一个纯Python实现的ssh协议库。 ansible.cfg配置文件概述 defaults默认配置项 privilege_escalation 执行命令的用户权限设置 paramiko_connection paramika 插件设置 ssh_connection ssh连接设置 accelerate selinux &amp; colors 模块查找及命令ansible配置文件优先级./ansible.cfg~/.ansible.cfg/etc/ansible/ansible.cfg 查看文档帮助https://docs.ansible.com/ 列出ansible 所有模块[root@localhost etc]#ansible-doc -l 查看指定模块的用法[root@localhost etc]#ansible-doc cron -m 表示指定模块名-a 表示指定命令-v显示过程v越多越详细，最多四个v-b ansible_become_user模块命令 测试所有连接的客户端:123456789[root@redis ansible]# ansible all -a &apos;who&apos; -k SSH password: 172.24.8.199 | SUCCESS | rc=0 &gt;&gt;root pts/0 2018-09-17 16:22 (172.24.2.100)root pts/1 2018-09-17 17:11 (172.24.1.114)172.24.50.50 | SUCCESS | rc=0 &gt;&gt;root pts/0 2018-09-17 16:22 (172.24.2.100)root pts/1 2018-09-17 17:10 (172.24.1.114) 测试ping注意:-m 表示指定模块名 -a 表示指定命令1234567891011121314151617181920212223询问密码:[root@redis ansible]# ansible all -m ping -kSSH password: 172.24.8.199 | SUCCESS =&gt; &#123; &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot;&#125;172.24.50.50 | SUCCESS =&gt; &#123; &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot;&#125;免密码:[root@redis ansible]# ansible test -m ping --key-file=~/.ssh/id_rsa172.24.8.199 | SUCCESS =&gt; &#123; &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot;&#125;172.24.50.50 | SUCCESS =&gt; &#123; &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot;&#125;[root@redis ansible]# 拷贝文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849**方法一：**ansible test -m copy -a &quot;src=/tmp/test.sh dest=/tmp/test.sh mode=0755&quot; -k SSH password: 172.24.50.50 | SUCCESS =&gt; &#123; &quot;changed&quot;: true, &quot;checksum&quot;: &quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;, &quot;dest&quot;: &quot;/tmp/test.sh&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;md5sum&quot;: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;, &quot;mode&quot;: &quot;0755&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;secontext&quot;: &quot;unconfined_u:object_r:admin_home_t:s0&quot;, &quot;size&quot;: 0, &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1537207289.26-118818605277140/source&quot;, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;**方法二：**vim test.yaml- name: test copy file hosts: - test tasks: - name: copy file copy: src: /etc/passwd dest: /tmp/passwd2 运行:[root@redis ansible]# ansible-playbook test.yaml -kSSH password: PLAY [test copy file] **********************************************************************************************************************************************************************************************************TASK [Gathering Facts] *********************************************************************************************************************************************************************************************************ok: [172.24.50.50]ok: [172.24.8.199]TASK [copy file] ***************************************************************************************************************************************************************************************************************changed: [172.24.50.50]changed: [172.24.8.199]PLAY RECAP *********************************************************************************************************************************************************************************************************************172.24.50.50 : ok=2 changed=1 unreachable=0 failed=0 172.24.8.199 : ok=2 changed=1 unreachable=0 failed=0 防火墙模块配置: 可选条件:1234567891011121314151617181920212223242526271. action: insert（默认append）1. source: 8.8.8.81. ctstate: ESTABLISHED,RELATED1. in_interface: eth01. destination :1. flush 1. source_port1. destination_port: 801. ctstate: NEW1. table: mangle&gt; #### 实现:[root@redis ansible]# ansible-playbook iptables.yaml --key-file=~/.ssh/id_rsa.pub ---- name: iptables hosts: - test tasks: - name: iptables iptables: chain: INPUT protocol: icmp jump: ACCEPT~ ~ root与普通用户免密 root用户123456789101 将root用户秘钥上传至目标服务器ssh-keygenssh-copy-id root@172.24.8.1992 vim /etc/ansible/hosts(也可以修改ansible.cfg修改此路径文件)，添加：[test]172.24.50.50 ansible_ssh_user=root ansible_ssh_private_key=~/.ssh/id_rsa172.24.8.199 ansible_ssh_user=root ansible_ssh_private_key=~/.ssh/id_rsa3 测试:ansible test -m ping -vvvv（查看详细） 普通用户12345678910111213141516171 将普通用户xfq的公钥上传至目标主机的xfq账户下su - xfqssh-keygenssh-copy-id xfq@172.24.8.1992 vim /etc/ansible/hosts 添加:## db-[99:101]-node.example.com[test]172.24.50.50 ansible_ssh_user=xfq ansible_ssh_private_key=/home/xfq/.ssh/id_rsa172.24.8.199 ansible_ssh_user=xfq ansible_ssh_private_key=/home/xfq/.ssh/id_rsa3 测试: ansible test -m command -a &apos;whoami&apos; -vvvv 也可以在命令行: ansible test -m command -a &apos;whoami&apos; -u xfq --key-file=/home/xfq/.ssh/id_rsa 运行结果: 172.24.8.199 | SUCCESS | rc=0 &gt;&gt; xfq 普通用户的华丽转生–&gt;拥有root权限原理就是将普通用户加入wheel组，并且启用ansible_become_user模块123456789101112131415161718192021222324252627282930313233343536373839404142434445一 添加普通用户到wheel开启wheelvim /etc/sudoers 取消下行注释，在ubuntu中是sudo %wheel ALL=(ALL) NOPASSWD: ALL vim /etc/groupwheel:x:10:xfq下面这一步有两种方法可以实现:方法一:vim /etc/ansible/ansible.cfg去掉下面注释:[privilege_escalation]become=True#become_method=sudobecome_user=root#become_ask_pass=False然后可以第三步的运行测试方法二: vim /etc/ansible/hosts[test]172.24.50.50 ansible_ssh_user=xfq ansible_ssh_pass=redhat ansible_become_user=root ansible_become=true172.24.8.199 ansible_ssh_user=xfq ansible_ssh_pass=redhat ansible_become_user=root ansible_become=true&quot;/etc/ansible/hosts&quot; 46L, 1140C 注意：将true改成false或者注释不写，便不能转变三 运行测试:ansible test -m command -a &apos;whoami&apos; -vvvv 172.24.8.199 | SUCCESS | rc=0 &gt;&gt;root172.24.50.50 | SUCCESS | rc=0 &gt;&gt;root普通用户已经切换至root用户为了便于分类管理,修改/etc/ansible/hosts文件，添加[test:vars][test]172.24.50.50172.24.8.199[test:vars]ansible_ssh_user=xfqansible_ssh_pass=redhatansible_become_user=rootansible_become=true&quot;/etc/ansible/hosts&quot; 52L, 1155C 简单实例 ansible all -m user -a “name=ansible shell=/sbin/nologin” ansible all -m user -a ‘name=ansible remove=yes state=absent’ ansible test -a ‘wall hello’ ansible all -m ping ansible all -m yum -a “name=httpd state=present” # 通过yum安装httpd ansible test -m yum -a ‘name=httpd state=removed’ ansible all -m service -a “name=httpd state=started enabled=yes” # 配置服务开启启动 ansible test -m service -a “name=httpd state=stopped”]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ansible--playbook]]></title>
    <url>%2F2018%2F09%2F28%2Fansible--playbook%2F</url>
    <content type="text"><![CDATA[基本语法规则 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略 YAML 支持的数据结构有三种。 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 playbookplaybook是由一个或多个“play”组成的列表。play的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲，所谓task无非是调用ansible的一个module。将多个play组织在一个playbook中，即可以让它们联同起来按事先编排的机制同唱一台大戏playbook中的每一个play的目的都是为了让某个或某些主机以某个指定的用户身份执行任务hosts用于指定要执行指定任务的主机，其可以是一个或多个由冒号分隔主机组；# playbook我们完成一个任务，例如安装部署一个httpd服务，我们需要多个模块（一个模块也可以称之为task）提供功能来完成。而playbook就是组织多个task的容器，他的实质就是一个文件，有着特定的组织格式，它采用的语法格式是YAML（Yet Another Markup Language）。YAML语法能够简单的表示散列表，字典等数据结构 playbook基础组件Hosts：运行执行任务（task）的目标主机remote_user：在远程主机上执行任务的用户tasks：任务列表handlers：任务，与tasks不同的是只有在接受到通知时才会被触发templates：使用模板语言的文本文件，使用jinja2语法。variables：变量，变量替换整个playbook是以task为中心，表明要执行的任务。hosts和remote_user表明在哪些远程主机以何种身份执行。其他组件让其能够更加灵活。 playbook调用方式用法：ansible-playbook &lt;filename.yml&gt; … [options] &lt;filename.yml&gt;:yaml格式的playbook文件路径，必须指明 [options]: 选项 -C, –check：并不在远程主机上执行，只是测试。 -i PATH, –inventory=PATH：资产的文件路径 –flush-cache：清楚fact缓存 –list-hosts：列出匹配的远程主机，并不执行任何动作 -t, TAGS, –tags=TAGS：运行指定的标签任务 –skip-tags:跳过指定的notify，后面详细介绍。 语法检测:ansible-playbook –syntax-check yun3.yaml 模拟执行:ansible-playbook –check yun3.yaml 查看copy模块的帮助ansible-doc copy123456789101112131415vim copy1.yaml---- name: test hosts: test vars: - authors: &quot;xiao&quot; - message: &quot;welcome to cloudclass&quot; tasks: - name: copy files copy: dest: /etc/motd content: &quot;welcome to &#123;&#123; ansible_fqdn &#125;&#125; the author is &#123;&#123; authors&#125;&#125; \n and the news is&#123;&#123; message&#125;&#125; \n&quot;上面代码意思是将test主机群的域名信息和vars下的信息拷贝到test主机中的/etc/motd文件 列出主机详细信息ansible test -m setup |less 显示主机ip123456789101112131415161718---vim ip.yaml- name: get ip address hosts: test,yun tasks: - name: get ip address debug: msg: | &#123;% for ip in ansible_all_ipv4_addresses %&#125; &quot;Host ip: &#123;&#123; ip &#125;&#125;&quot; &#123;% endfor %&#125;运行:ansible-playbooks ip.yamlPLAY RECAP ************************************120.78.156.84 : ok=2 changed=0 unreachable=0 failed=0 172.24.50.50 : ok=2 changed=0 unreachable=0 failed=0 172.24.8.199 : ok=2 changed=0 unreachable=0 failed=0 将变量文件放在一个目录中12345678910111213141516171819202122232425 mkdir conf.d vim apache_cnf 添加以下(不要有-): --- apache_listen_port : 8888 apache_user : apache 编辑play文件yun3.yaml- name: include other file hosts: test vars_files: - conf.d/apache.cnf tasks: - name: include conf.d file debug: msg: &quot;the apache port is &#123;&#123; apache_listen_port &#125;&#125;&quot; 运行: ansible-playbook yun3.yamlTASK [include conf.d file] *********************************************************ok: [172.24.50.50] =&gt; &#123; &quot;msg&quot;: &quot;the apache port is 8888&quot;&#125;ok: [172.24.8.199] =&gt; &#123; &quot;msg&quot;: &quot;the apache port is 8888&quot;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ansible-roles角色]]></title>
    <url>%2F2018%2F09%2F28%2Fansible-roles%E8%A7%92%E8%89%B2%2F</url>
    <content type="text"><![CDATA[部署mysql+apache服务 创建工作目录：/etc/ansible/fstroles[root@two ansible]# mkdir fstroles[root@two ansible]# cd fstroles/ 创建角色roles[root@two fstroles]# mkdir roles[root@two fstroles]# lsroles 初始化三个任务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[root@two fstroles]# cd roles/[root@two roles]# ansible-galaxy init common- common was created successfully[root@two roles]# ansible-galaxy init database- database was created successfully[root@two roles]# ansible-galaxy init webserver- webserver was created successfully初始化后如下:[root@two fstroles]# tree.└── roles ├── common │ ├── defaults │ │ └── main.yml │ ├── files │ ├── handlers │ │ └── main.yml │ ├── meta │ │ └── main.yml │ ├── README.md │ ├── tasks │ │ └── main.yml │ ├── templates │ ├── tests │ │ ├── inventory │ │ └── test.yml │ └── vars │ └── main.yml ├── database │ ├── defaults │ │ └── main.yml │ ├── files │ ├── handlers │ │ └── main.yml │ ├── meta │ │ └── main.yml │ ├── README.md │ ├── tasks │ │ └── main.yml │ ├── templates │ ├── tests │ │ ├── inventory │ │ └── test.yml │ └── vars │ └── main.yml └── webserver ├── defaults │ └── main.yml ├── files ├── handlers │ └── main.yml ├── meta │ └── main.yml ├── README.md ├── tasks │ └── main.yml ├── templates ├── tests │ ├── inventory │ └── test.yml └── vars └── main.yml28 directories, 24 files 首先编写共同任务common12345678910111213141516171819共两个共同任务，就是创建用户和设置防火墙 vim roles/common/tasks/main.yml ---# tasks file for common - name: Create user name tiancan user: uid: 2233 name: tiancan password: $6$rounds=656000$y4RkLR0z.L/nEMD4$57eCsCKPcvwAzxuUaLbKItXMWOmPBui1ErBv51dV7.Q7knC.9vTJhRiYnR0lG0ffjjnQ.mgsmd0XSzXRlRq3U1 //采用sha512加密，原文:redhat - name: setup iptables iptables: chain: INPUT jump: ACCEPT protocol: tcp destination_port: &quot;&#123;&#123; item &#125;&#125;&quot; with_items: - 80 - 3306 编写database任务1234567891011121314vim roles/database/tasks/main.yml---# tasks file for database- name: install mysql-redhat yum: name: mysql-server state: present when: ansible_os_family == &quot;RedHat&quot;- name: install mysql-debian apt: name: mysql-server state: present when: ansible_os_family == &quot;Debian&quot; 编写webserver任务123456789101112131415161718vim roles/webserver/tasks/main.yml---# tasks file for webserver- name: install apache-redhat yum: name: &quot;&#123;&#123; item &#125;&#125;&quot; state: present with_items: - httpd - httpd-manual - httpd-tools when: ansible_os_family == &quot;RedHat&quot;- name: install apache-debian apt: name: apache2 state: present when: ansible_os_family == &quot;Debian&quot; 最后编写调用文件调用database任务文件1234567891011121314[root@two fstroles]# pwd/etc/ansible/fstrolesvim test_roles_database.yaml--- - name: Apply multiple roles for hosts hosts: test tasks: - name: Debug message debug: msg: &quot;common and database&quot; roles: - common - database 同样编写调用webserver任务文件123456789101112 vim test_roles.webserver.yaml --- - name: Apply multiple roles for hosts hosts: yun tasks: - name: Debug message debug: msg: &quot;common and webserver&quot; roles: - common - webserver 开启部署[root@two fstroles]# ansible-playbook test_roles_database.yaml[root@two fstroles]# ansible-playbook test_roles.webserver.yaml vars:123456789101112131415161718[root@two fstroles]# vim roles/common/vars/main.yml---# vars file for common port: 80 author: xiaokun 引用变量:[root@two fstroles]# vim test_roles.webserver.yaml test_roles.webserver.yaml--- - name: Apply multiple roles for hosts hosts: fight tasks: - name: Debug message debug: msg: &quot;common and webserver &#123;&#123; author &#125;&#125;&quot; roles: - common - webserver inventory.ini同hosts同样的作用12345678910[root@two fstroles]# vim myinventory.ini[fight]172.24.25.25[fight:vars]ansible_ssh_user=rootansible_ssh_pass=redhat调用:[root@two fstroles]# ansible-playbook test_roles.webserver.yaml -i ./myinventory.ini handlers调用模拟12345678910111213141516171819202122232425262728293031323334[root@two fstroles]# vim roles/common/handlers/main.yml---# handlers file for common- name: trigger debug: msg: &quot;trigger a handler for&quot;---# tasks file for common - name: Create user name tiancan user: uid: 2233 name: tiancan password: $6$rounds=656000$y4RkLR0z.L/nEMD4$57eCsCKPcvwAzxuUaLbKItXMWOmPBui1ErBv51dV7.Q7knC.9vTJhRiYnR0lG0ffjjnQ.mgsmd0XSzXRlRq3U1 - name: setup iptables iptables: chain: INPUT jump: ACCEPT protocol: tcp destination_port: &quot;&#123;&#123; item &#125;&#125;&quot; with_items: - 80 - 3306 notify: trigger //调用handlers 运行: [root@two fstroles]# ansible-playbook test_roles.webserver.yaml -i ./myinventory.ini RUNNING HANDLER [common : trigger] *****************************************************************ok: [172.24.25.25] =&gt; &#123; &quot;msg&quot;: &quot;trigger a handler for&quot; //被调用&#125; tags标签查看某任务所调用的主机群 [root@two fstroles]# ansible-playbook –list-hosts ./test_roles.webserver.yaml 给任务添加标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647--- - name: Apply multiple roles for hosts hosts: fight tasks: - name: Debug a message debug: msg: &quot;common and webserver&#123;&#123; port &#125;&#125; and author &#123;&#123; author &#125;&#125;&quot; tags: showinfo - name: Debug b message debug: msg: &quot;common and webserver&#123;&#123; port &#125;&#125; and author &#123;&#123; author &#125;&#125;&quot; tags: - showinfo - check - name: Debug c message debug: msg: &quot;common and webserver&#123;&#123; port &#125;&#125; and author &#123;&#123; author &#125;&#125;&quot; tags: check roles: - common - webserver执行:[root@two fstroles]# ansible-playbook test_roles.webserver.yaml -i ./myinventory.ini --tags checkPLAY [Apply multiple roles for hosts] *************************************************************TASK [Gathering Facts] ************************************************************************ok: [172.24.25.25]TASK [Debug b message] *************************************************************************ok: [172.24.25.25] =&gt; &#123; &quot;msg&quot;: &quot;common and webserver80 and author xiaokun&quot;&#125;TASK [Debug c message] ************************************************************************ok: [172.24.25.25] =&gt; &#123; &quot;msg&quot;: &quot;common and webserver80 and author xiaokun&quot;&#125;PLAY RECAP ***********************************************************************************************172.24.25.25 : ok=3 changed=0 unreachable=0 failed=0 可以看到只有check标签的任务执行了。 加文: 使用ansible的user模块进行用户名创建和设置密码时，密码必须是加过密的可以使用 mkpasswd -m sha-512 回车输入密码即可获得，如果此方法不行，可以调用python的passlib.hash库来加密,如下: 12345&gt;&gt;&gt; from passlib.hash import sha512_crypt&gt;&gt;&gt; hash = sha512_crypt.hash(&quot;redhat&quot;)&gt;&gt;&gt; hash&apos;$6$rounds=656000$y4RkLR0z.L/nEMD4$57eCsCKPcvwAzxuUaLbKItXMWOmPBui1ErBv51dV7.Q7knC.9vTJhRiYnR0lG0ffjjnQ.mgsmd0XSzXRlRq3U1&apos;&gt;&gt;&gt; quit()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python-os模块]]></title>
    <url>%2F2018%2F09%2F28%2Fpython-os%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[文件系统操作库:os dir(os) 显示os库内置函数 help(os.mkdir)显示函数操作帮助 os.mkdir() [make directory] os.rmdir() [remove directory] os.getcwd()[current working directory] os.chdir() [change directory] os.rename() os.listdir() os.makedirs() os.removedirs()123456789101112131415161718192021&gt;&gt;&gt; os.mkdir(&apos;/tmp/e1&apos;)&gt;&gt;&gt; os.mkdir(&apos;/tmp/e2&apos;)&gt;&gt;&gt; &gt;&gt;&gt; os.rmdir(&apos;/tmp/e1&apos;)&gt;&gt;&gt; os.rmdir(&apos;/tmp/e2&apos;)&gt;&gt;&gt; &gt;&gt;&gt; os.getcwd()&apos;/var/python&apos;&gt;&gt;&gt; os.chdir(&apos;/var/python&apos;)&gt;&gt;&gt; os.getcwd()&apos;/var/python&apos;&gt;&gt;&gt; os.chdir(&apos;/tmp&apos;)&gt;&gt;&gt; os.getcwd()&apos;/tmp&apos;&gt;&gt;&gt; &gt;&gt;&gt; os.rename(&apos;ip_txt&apos;,&apos;ip2.txt&apos;)&gt;&gt;&gt; &gt;&gt;&gt; os.listdir(&apos;/var/python&apos;)[&apos;test.py&apos;, &apos;passwd.py&apos;, &apos;dic&apos;, &apos;sanjiao.py&apos;, &apos;jubu.py&apos; ]&gt;&gt;&gt; os.makedirs(&apos;/tmp/m1/m2/m3&apos;)&gt;&gt;&gt; os.removedirs(&apos;/tmp/m1/m2/m3&apos;) //删除m1/m2/m3文件夹 重点函数:os.walk()os.walk是一个简单易用的文件、目录遍历器os.walk的函数声明为:++walk(top, topdown=True, onerror=None, followlinks=False)++123456参数top 是你所要便利的目录的地址topdown 为真，则优先遍历top目录，否则优先遍历top的子目录(默认为开启)onerror 需要一个 callable 对象，当walk需要异常时，会调用followlinks 如果为真，则会遍历目录下的快捷方式(linux 下是 symbolic link)实际所指的目录(默认关闭)os.walk 的返回值是一个生成器(generator),也就是说我们需要不断的遍历它，来获得所有的内容 123456789101112131415161718192021222324创建目录:[root@suiyuewuheng /]# tree walklwalkl├── file1├── file2├── wa1│ ├── file3│ └── wawa1└── wa2开始遍历:&gt;&gt;&gt; wal=os.walk(&apos;/walkl&apos;)&gt;&gt;&gt; wal.next()(&apos;/walkl&apos;, [&apos;wa1&apos;, &apos;wa2&apos;], [&apos;file2&apos;, &apos;file1&apos;]) //从左至右依次是:路径 目录 文件&gt;&gt;&gt; wal.next()(&apos;/walkl/wa1&apos;, [&apos;wawa1&apos;], [&apos;file3&apos;])&gt;&gt;&gt; wal.next()(&apos;/walkl/wa1/wawa1&apos;, [], [])&gt;&gt;&gt; wal.next()(&apos;/walkl/wa2&apos;, [], [])&gt;&gt;&gt; wal.next()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 编写文件搜索脚本:12345678910111213141516171819#!/usr/bin/pythonimport osimport syspath=sys.argv[1]filename=sys.argv[2]for (curpath,subpath,files) in os.walk(path): for f in files: if filename == f print &quot;%s has the file %s&quot; % (curpath,filename)运行:[root@suiyuewuheng python]# python walk.py /etc sshd/etc/pam.d has the file sshd/etc/sysconfig has the file sshd[root@suiyuewuheng python]# python walk.py /walkl/ file3/walkl/wa1 has the file file3 列出目录下文件123456789101112#!/usr/bin/pythonimport osimport syspath=sys.argv[1]for (curpath,subpath,files) in os.walk(path): for f in files: print &quot;%s%s&quot; % (curpath,f)运行:[root@suiyuewuheng python]# python walk.py /var/python/ |grep passwd/var/python/passwd.py/var/python/passwd os.pathimport osimport os.path os.getsize() os.path.basename() os.path.dirname() 1234567891011121314&gt;&gt;&gt; os.path.getsize(&apos;/etc/passwd&apos;)1593&gt;&gt;&gt; &gt;&gt;&gt; os.path.basename(&apos;/etc/sysconfig/network-scripts/ifcfg-eth0&apos;)&apos;ifcfg-eth0&apos;&gt;&gt;&gt; &gt;&gt;&gt; os.path.dirname(&apos;/etc/sysconfig/network-scripts/ifcfg-eth0&apos;)&apos;/etc/sysconfig/network-scripts&apos;&gt;&gt;&gt; &gt;&gt;&gt; os.path.getatime(&apos;/etc/passwd&apos;)1537340950.5578592&gt;&gt;&gt; time.ctime(os.path.getatime(&apos;/etc/passwd&apos;))&apos;Wed Sep 19 15:09:10 2018&apos;&gt;&gt;&gt; 获取文件修改时间案例:12345678910111213141516171819202122#!/usr/bin/pythonimport osimport os.pathimport sysimport timepath=sys.argv[1]record_file=&apos;/tmp/record.txt&apos;fh=open(record_file,&apos;w+&apos;)for curpath,subpath,files in os.walk(path,followlinks=True): for f in files: filename=&quot;%s/%s&quot; %(curpath,f) content = &quot;%s:%s\n&quot; % (filename, str(time.ctime(os.path.getmtime(filename)))) fh.write(content)fh.close()运行:python shijian.py[root@suiyuewuheng python]# cat /tmp/record.txt /var/python/passwd.py:Wed Sep 12 15:39:16 2018/var/python/dic:Wed Sep 12 15:34:59 2018/var/python/sanjiao.py:Fri Sep 14 14:00:50 2018]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python-导包]]></title>
    <url>%2F2018%2F09%2F28%2Fpython%E6%A8%A1%E5%9D%97-%E5%AF%BC%E5%85%A5-%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[.py和.pyc文件++Python的程序中，是把原始程序代码放在.py文件里，而Python会在执行.py文件的时候。将.py形式的程序编译成中间式文件（byte-compiled）的.pyc文件，这么做的目的就是为了加快下次执行文件的速度。所以，在我们运行python文件的时候，就会自动首先查看是否具有.pyc文件，如果有的话，而且.py文件的修改时间和.pyc的修改时间一样，就会读取.pyc文件，否则，Python就会读原来的.py文件。其实并不是所有的.py文件在与运行的时候都会差生.pyc文件，只有在import相应的.py文件的时候，才会生成相应的.pyc文件，所以有时候为了一些隐秘可以将pyc文件给他人，这样源代码不会暴露++ 添加环境变量++export PYTHONPATH=$PYTHONPATH:/forum++++source /etc/profile++ sys.path import sys sys.pathsys.path指定用于模块搜索路径的字符串列表。它根据环境变量PYTHONPATH进行初始化，再加上安装时的默认值。 一次导入一个1234567891011121314&gt;&gt;&gt; import sushu as su 或者import sushu&gt;&gt;&gt; dir(su)[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;suhsu&apos;]&gt;&gt;&gt; su.suhsu()10 不是素数11 是素数&gt;&gt;&gt;从某个模块中导入某个函数，可以直接使用&gt;&gt;&gt; from os import chdir,listdir&gt;&gt;&gt; dir()[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;chdir&apos;, &apos;listdir&apos;, &apos;os&apos;, &apos;su&apos;]&gt;&gt;&gt; chdir(&apos;/var&apos;)&gt;&gt;&gt; 批量导入1import mod1.mod2,mod3 从zip文件中导入1234567891011121314151617181920[root@suiyuewuheng python]# zip test.zip ./test/* adding: test/add.py (deflated 21%) adding: test/sanjiao3.py (deflated 42%) adding: test/sanjiao.py (deflated 39%) adding: test/seekfile.py (deflated 39%) adding: test/shijian2.py (deflated 42%) adding: test/shijian.py (deflated 40%) adding: test/sushu.py (deflated 40%)&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/var/python/test.zip&apos;)&gt;&gt;&gt; import sushu&gt;&gt;&gt; dir(sushu)[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;suhsu&apos;]&gt;&gt;&gt; sushu.suhsu()10 不是素数11 是素数11 不是素数12 不是素数13 是素数 导入打包模块 不能自己导自己，也就是不能在函数中导入与该文件名相同的模块 先后导入的模块中如果包含相同的函数名，则函数以后者为准 123456789101112131415161718192021222324252627282930313233343536为了能够让python识别，每个目录下需要创建一个 __init.py__初始化文件结构如下:[root@suiyuewuheng /]# tree forum/forum/├── admin│ ├── __init__.py│ ├── __init__.pyc│ ├── post.py│ └── post.pyc├── guest│ ├── __init__.py│ └── sanjiao2.py├── __init__.py└── user ├── abc.py ├── abc.pyc ├── __init__.py └── __init__.pyc3 directories, 11 files[root@suiyuewuheng /]# [root@suiyuewuheng /]# python&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/forum&apos;)&gt;&gt;&gt;sys.path //查看路径是否已添加&gt;&gt;&gt; import forum.user.abc&gt;&gt;&gt; dir()[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;admin&apos;, &apos;os&apos;, &apos;post&apos;, &apos;sys&apos;, &apos;user&apos;]&gt;&gt;&gt; dir(user)[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;abc&apos;]&gt;&gt;&gt; dir(user.abc)[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;rra&apos;]&gt;&gt;&gt; user.abc.rra() //调用rra()函数&apos;hello&apos; &gt;&gt;&gt; name main123__name__指的是当前文件的模块名当我们在函数中打印__name__变量时，print(__name__)，结果会输出__main__,而当我们在别的文件中调用该模块时，打印的__name__变量就变成了文件名，而不再是__main__，所以我们可以在原模块中添加一句if __name__ == &apos;__main__&apos;: 来进行判断，如果本地执行，则会执行后续代码，如果被调用，则条件不成立，不会执行后续代码，避免干扰]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python-循环]]></title>
    <url>%2F2018%2F09%2F28%2Fpython%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[for循环 for循环的语法格式如下:for iterating_var in sequence: statements(s) while循环 while循环基本形式为:while 判断条件： 执行语句…… 12执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。当判断条件假false时，循环结束。 if-else小案例:**注意，这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了 1234567891011121314151617181920212223242526272829#### 检测成绩vim grade.py#!/bin/bash score = int(raw_input(&apos;PLS input score: &apos;))if score &lt; 60 : print &quot;Failed&quot; //前面打上四个空格，控制格式 ，下同 elif score &gt;= 60 print &quot;Pass&quot; elif score &gt; 75 print &quot;Good&quot; else: print &quot;exclent&quot; 运行:[root@suiyuewuheng python]# python grage2.py PLS input score: 55Failed[root@suiyuewuheng python]# python grage2.py PLS input score: 89exclent#### 从小到大逆序:age = 54if age &lt;=6: print &apos;kid&apos;elif age &lt;=18: print &apos;teenager&apos;else: print &apos;adult&apos; continue continue 语句是一个删除的效果，他的存在是为了删除满足循环条件下的某些不需要的成分: 12345678910111213141516171819202122232425continue 语句是一个删除的效果，他的存在是为了删除满足循环条件下的某些不需要的成分:计算60分以上的和，使用continue&gt;&gt;&gt; L=[23,54,60,65,78,34,90]&gt;&gt;&gt; sum=0&gt;&gt;&gt; n=0&gt;&gt;&gt; for x in L:... if x&lt;60:... continue... sum=sum+x... n=n+1... &gt;&gt;&gt; print sum293计算1-100的奇数和，使用continuesum = 0x = 0while True: x = x + 1 if x &gt;100: break if x%2==0: continue sum=sum+xprint sum 用户信息1234567891011121314vim dic#!/usr/bin/python2s1 = &#123;&apos;name&apos;:&apos;jake&apos;,&apos;age&apos;:23,&apos;addr&apos;:&apos;xiangtan&apos;&#125;s2 = &#123;&apos;name&apos;:&apos;jak&apos;,&apos;age&apos;:23,&apos;addr&apos;:&apos;xiangtan&apos;&#125;s3 = &#123;&apos;name&apos;:&apos;ja&apos;,&apos;age&apos;:23,&apos;addr&apos;:&apos;xiangtan&apos;&#125;students = [s1,s2,s3]fam = [one for one in students if one[&apos;name&apos;]==&apos;ja&apos;]print fam运行:[root@suiyuewuheng python]# python dic[&#123;&apos;age&apos;: 23, &apos;name&apos;: &apos;ja&apos;, &apos;addr&apos;: &apos;xiangtan&apos;&#125;][root@suiyuewuheng python]# 打印金三角1234567891011#!/usr/bin/python2for i in range(1,5): print (&apos; &apos; * (5-i) + &apos;*&apos; *(2*i-1) )运行[root@suiyuewuheng python]# python sanjiao.py * *** ***** *******[root@suiyuewuheng python]# 123456while循环实现#!/usr/bin/python2i=1while i&lt;=5: print (&apos; &apos;*(5-i) + &apos;*&apos;*(2*i-1)) i+=1 123456倒三角#!/usr/bin/python2i=5while i&gt;=1: print (&apos; &apos;*(5-i) + &apos;*&apos;*(2*i-1)) i-=1 判断素数123456789#!/usr/bin/python2# -*- coding: utf-8 -*for i in range(10,20): for j in (2,i): if i%j==0: print i, &quot;不是素数&quot; break else: print i, &quot;是素数&quot; 打印对称数123print [a*100+b*10+c for a in range(1,10) for b in range(0,10) for c in range(1,10) if a==c]运行结果：[101, 111, 121, 131, 141, 151, 161, 171, 181, 191.....]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python-函数]]></title>
    <url>%2F2018%2F09%2F28%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数名其实就是指向函数的变量，指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名” 函数名其实就是指向函数的变量12345&gt;&gt;&gt; abs(-10)10&gt;&gt;&gt; b=abs&gt;&gt;&gt; b(-10)10 简化多行式123456789101112131415&gt;&gt;&gt; def add(x):... return x+x... &gt;&gt;&gt; alist = [1,2,3,4,5]&gt;&gt;&gt; temp = []&gt;&gt;&gt; for num in alist:... temp.append(add(num))... &gt;&gt;&gt; temp[2, 4, 6, 8, 10]&gt;&gt;&gt; temp2 = []&gt;&gt;&gt; temp2 = [add(num) for num in alist]&gt;&gt;&gt; temp2[2, 4, 6, 8, 10]&gt;&gt;&gt; 例子：求某个数的多次方12345678910&gt;&gt;&gt; def power(x,n):... s=1... while(n&gt;0):... n=n-1... s=s*x... return s... 运行：&gt;&gt;&gt; power(2,3)8&gt;&gt;&gt; 定义默认参数*tuple_args **dict_args12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def greet(a=&apos;world&apos;): print &apos;hello&apos;,a greet() greet(&apos;Bart&apos;)运行：hello worldhello Bart默认参数需在非默认参数之后&gt;&gt;&gt; def bar(x=87,y):... return x*y... File &quot;&lt;stdin&gt;&quot;, line 1SyntaxError: non-default argument follows default argument&gt;&gt;&gt; def bar(y,x=34):... return x*y... &gt;&gt;&gt; bar(10,23)230&gt;&gt;&gt;小案例:&gt;&gt;&gt; def reg(name,sex=&quot;male&quot;):... print &quot;%s is %s &quot; % (name,&quot;boy&quot; if sex == &apos;male&apos; else &quot;girl&quot;)... &gt;&gt;&gt; 运行：&gt;&gt;&gt; reg(&apos;xiao&apos;)xiao is boy &gt;&gt;&gt; 默认tuple参数&gt;&gt;&gt; def alist(*b):... total=0... for i in b:... total+=i... return total... &gt;&gt;&gt; alist(*blist)33默认字典参数&gt;&gt;&gt; def bar(**host):... return host[&apos;name&apos;]... &gt;&gt;&gt; host1=&#123;&apos;name&apos;:&apos;xiao&apos;&#125;&gt;&gt;&gt; bar(**host1)&apos;xiao&apos;&gt;&gt;&gt; 空函数如果想定义一个什么事也不做的空函数，可以用pass语句： 123456789def nop(): passpass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。pass还可以用在其他语句里，比如：if age &gt;= 18: pass缺少了pass，代码运行就会有语法错误。 lambda表达式123456789101112131415161718列表指定元素排序:&gt;&gt;&gt; a=[(10, 5), (3, 1), (4, 2), (8, 10)]&gt;&gt;&gt; a.sort(key=lambda x:x[1])&gt;&gt;&gt; a[(3, 1), (4, 2), (10, 5), (8, 10)]&gt;&gt;&gt; a.sort(key=lambda x:x[1],reverse=True)&gt;&gt;&gt; a[(8, 10), (10, 5), (4, 2), (3, 1)]&gt;&gt;&gt; a.sort(key=lambda x:x[0])&gt;&gt;&gt; a[(3, 1), (4, 2), (8, 10), (10, 5)]&gt;&gt;&gt; a.sort(key=lambda x:x[0],reverse=True)&gt;&gt;&gt; a[(10, 5), (8, 10), (4, 2), (3, 1)]&gt;&gt;&gt; 两列表综合输出大的元素&gt;&gt;&gt; map(lambda x,y:x if x&gt;y else y, list1, list2) 导入自己创建的库1234567891011121314151617181920212223242526272829303132333435363738&gt; 创建vim mytools.py#!/usr/bin/python2&quot;&quot;&quot; author:xiao descrption:this is a tools&quot;&quot;&quot;import timeimport osimport sysdef add(x,y): &apos;&apos;&apos;x: &lt;int&gt; number a y: &lt;int&gt; number b add(x,y) --&gt; sum of x and y &apos;&apos;&apos; return x+ydef sub(xy): return x-y &gt; 导入[root@suiyuewuheng ~]# pythonPython 2.7.5 (default, Nov 6 2016, 00:28:07) [GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import mytools&gt;&gt;&gt; dir(mytools)[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;add&apos;, &apos;os&apos;, &apos;sub&apos;, &apos;sys&apos;, &apos;time&apos;]&gt;&gt;&gt; help(mytools.add)Help on function add in module mytools:add(x, y) x: &lt;int&gt; number a y: &lt;int&gt; number b add(x,y) --&gt; sum of x and y(END) 异常处理 什么是异常？异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常异常是Python对象，表示一个错误。当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python#encoding:UTF-8try: fh=open(&quot;test.py&quot;) fh.write(&quot;测试异常!!&quot;)except: print &quot;测试有问题,执行下面语句&quot;print &quot;执行&quot;运行:[root@suiyuewuheng python]# python try.py 测试有问题,执行下面语句执行&gt; 因为没有写权限，所以写入失败，抛出异常，如果给予写权限，将会咋样？如下：修改文件，给予w权限#!/usr/bin/python#encoding:UTF-8try: fh=open(&quot;test.py&quot;,&apos;w&apos;) #需要判断是否会抛出异常的代码，如果没有异常处理，python会直接停止执行程序 fh.write(&quot;测试异常!!&quot;)except: #这里会捕捉到上面代码中的异常，并根据异常抛出异常处理信息 print &quot;测试有问题,执行下面语句&quot;print &quot;执行&quot; #如果没有异常则执行else&gt; 运行：[root@suiyuewuheng python]# python try.py 执行[root@suiyuewuheng python]# cat test.py 测试异常!!&gt; 正确输出，没有抛出异常，信息已写入文件//再来测试一个python类class Person(object): def __init__(self, name, score): self.name=name self.__score=scorep = Person(&apos;Bob&apos;, 59)print p.nametry: print p.__scoreexcept AttributeError: print &quot;attributeerror&quot;综上，我们可以看出，异常处理就是对程序的可执行的一种保护，使程序能依旧运行，不会因为异常错误而终止，但是不再执行异常错误里面后面的代码，而是异常块之外的代码，一句话：有异常抛出异常，继续运行异常块外程序，没有异常则不抛出异常，正确执行程序。 高阶函数 能接受函数做参数的函数 原理:变量可以指向函数–&gt;函数的参数可以接受变量–&gt;一个函数可以接受另一个函数作为参数–&gt;高阶函数12345678910111213&gt;&gt;&gt; def sub(f,x,y):... return f(x)+f(y)... &gt;&gt;&gt; sub(abs,-6,2)8再如:import mathdef add(x, y, f): return f(x) + f(y)print add(25, 9, math.sqrt)math.sqrt计算x的1/2次方 在python中返回函数12345678def calc_prod(lst): def jisun(): return reduce(lambda x,y:x*y,lst) return jisunf = calc_prod([1, 2, 3, 4]) //令f等于外层函数的返回值jisun，而jisuan是指向jisun()函数的变量，所以f()表示调用jisun()函数print f()运行结果:24 python中闭包 ++内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变，如上实例++ 将输入用户名格式化首字母大写，其余小写1234567891011def format_name(s): return s[0].upper()+s[1:].lower()print map(format_name, [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;])输出:[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]简化:&gt;&gt;&gt; map(lambda x:x[0].upper()+x[1:].lower(), [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;])输出:[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]也可以用函数 title() reduce()高阶内置函数reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。12345678910111213def prod(x, y): return x*yprint reduce(prod, [2, 4, 5, 7, 12])运行结果:3360 //列表所有有元素的乘积&gt;&gt;&gt; reduce(lambda x,y:x*y,[1,2,3,4,5])120求6的阶乘&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,7))720&gt;&gt;&gt; filter() filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; ages = [5, 12, 17, 18, 24, 32]&gt;&gt;&gt; adults = filter(lambda x:x&lt;18, ages)&gt;&gt;&gt; for x in adults:... print(x)... 51217&gt;&gt;&gt; 匹配出奇数&gt;&gt;&gt; a=filter(lambda x:x%2!=0, range(1,20))&gt;&gt;&gt; a[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]&gt;&gt;&gt; 匹配平方根是整数&gt;&gt;&gt; a=filter(lambda x:math.sqrt(x)%1==0,range(1,20))&gt;&gt;&gt; a[4, 16]查看某库以特定字符开头的函数&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;s&apos;),dir(&apos;&apos;)) [&apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;]&gt;&gt;&gt; import os&gt;&gt;&gt; import os.path&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;ch&apos;),dir(os)) [&apos;chdir&apos;, &apos;chmod&apos;, &apos;chown&apos;, &apos;chroot&apos;]&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;ch&apos;),dir(os.path)) []&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;get&apos;),dir(os.path)) [&apos;getatime&apos;, &apos;getctime&apos;, &apos;getmtime&apos;, &apos;getsize&apos;]&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;s&apos;),dir()) []&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;s&apos;),dir(&apos;&apos;)) [&apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;]&gt;&gt;&gt; 递归函数 求某数的阶乘1234567891011&gt;&gt;&gt; def jie(x):... if x==1:... return 1... else:... return x*jie(x-1)... &gt;&gt;&gt; jie(4)24&gt;&gt;&gt; jie(6)720&gt;&gt;&gt; yield代替return123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; def jyg():... return 10... return 100... return 1000... &gt;&gt;&gt; jyg()10&gt;&gt;&gt; jyg()10使用yield代替return，取出下一个值&gt;&gt;&gt; def jyg():... yield 10... yield 100... &gt;&gt;&gt; jyg()&lt;generator object jyg at 0x7fa71cb8dc80&gt;使用next()去下一个结果每次取出一个结果&gt;&gt;&gt; def getnum():... while True:... yield random.randint(1,10)... &gt;&gt;&gt; getnum()&lt;generator object getnum at 0x7fa71cbabdc0&gt;&gt;&gt;&gt; getnum().next()9&gt;&gt;&gt; &gt;&gt;&gt; getnum().next()4&gt;&gt;&gt; getnum().next()3&gt;&gt;&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python物语-内置函数]]></title>
    <url>%2F2018%2F09%2F15%2Fpython%E7%89%A9%E8%AF%AD-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[a.find()截取特定字符串 find方法可以在一个较长的字符串中查找子字符串。它返回子串所在位置的最左端索引。如果没有找到则返回-11234567891011&gt;&gt;&gt; a = &apos;test&apos;&gt;&gt;&gt; a.find(&apos;s&apos;)2&gt;&gt;&gt;info = &apos;abca&apos;&gt;&gt;&gt; print info.find(&apos;a&apos;) # 从下标0开始，查找在字符串里第一个出现的子串，返回结果：00&gt;&gt;&gt; print info.find(&apos;a&apos;,1) # 从下标1开始，查找在字符串里第一个出现的子串：返回结果33&gt;&gt;&gt; print info.find(&apos;3&apos;) # 查找不到返回-1-1&gt;&gt;&gt; 截取某段字符串。12345&gt;&gt;&gt; a = &quot;i want my tears back&quot;&gt;&gt;&gt; b = a[a.find(&apos;w&apos;):a.find(&apos;s&apos;)]&gt;&gt;&gt; b&apos;want my tear&apos;&gt;&gt;&gt; join1234567891011121314151617181920212223242526272829join方法是非常重要的字符串方法，它是split方法的逆方法，用来在队列中添加元素。注意：需要添加的队列元素都必须是字符串。&gt;&gt;&gt; test = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]&gt;&gt;&gt; out = &apos;+&apos;.join(test)&gt;&gt;&gt; out&apos;a+b+c+d&apos;数字与字符转换&gt;&gt;&gt; blist=[random.randint(1,20) for i in range(10)]&gt;&gt;&gt; blist[3, 14, 1, 15, 16, 13, 9, 8, 10, 3]&gt;&gt;&gt; clist=[str(e) for e in blist] &gt;&gt;&gt; clist[&apos;3&apos;, &apos;14&apos;, &apos;1&apos;, &apos;15&apos;, &apos;16&apos;, &apos;13&apos;, &apos;9&apos;, &apos;8&apos;, &apos;10&apos;, &apos;3&apos;]&gt;&gt;&gt; &apos;&apos;.join(clist)&apos;314115161398103&apos;&gt;&gt;&gt; &apos;-&apos;.join(clist)&apos;3-14-1-15-16-13-9-8-10-3&apos;&gt;&gt;&gt; &apos;*&apos;.join(clist)&apos;3*14*1*15*16*13*9*8*10*3&apos;&gt;&gt;&gt; 浮点类型&gt;&gt;&gt; dlist=[1.2,12.3,4.0,5.5]&gt;&gt;&gt; elist=[ &apos;%.2f&apos; % e for e in dlist]&gt;&gt;&gt; elist[&apos;1.20&apos;, &apos;12.30&apos;, &apos;4.00&apos;, &apos;5.50&apos;]&gt;&gt;&gt; &apos;*&apos;.join(elist)&apos;1.20*12.30*4.00*5.50&apos;&gt;&gt;&gt; replace() replace方法返回某个字符串的所有匹配项均被替换之后得到的字符串。12345678910111213141516&gt;&gt;&gt; a = &apos;hello world&apos;&gt;&gt;&gt; b = a.replace(&apos;r&apos;,&apos;l&apos;)&gt;&gt;&gt; b&apos;hello wolld&apos;&gt;&gt;&gt;&gt;&gt;&gt; a&apos;dsaasdfa0&apos;&gt;&gt;&gt; b=a.replace(&apos;a&apos;,&apos;s&apos;,2)&gt;&gt;&gt; b&apos;dssssdfa0&apos;&gt;&gt;&gt; b=a.replace(&apos;a&apos;,&apos;s&apos;,1)&gt;&gt;&gt; b&apos;dssasdfa0&apos;&gt;&gt;&gt; 其中2,1表示替换字符不超过2,1次 len()123456&gt; 获取对象长度&gt;&gt;&gt; a = &apos;hello world&apos;&gt;&gt;&gt; b = len(a)&gt;&gt;&gt; b11&gt;&gt;&gt; 连接字符串123456&gt;&gt;&gt; a=&apos;dsfa&apos;&gt;&gt;&gt; b=&apos;&apos;&gt;&gt;&gt; c=&apos;sd&apos;&gt;&gt;&gt; a+b+c&apos;dsfasd&apos;&gt;&gt;&gt; cmp 比较字符串1234567891011121314151617&gt;&gt;&gt; a = &apos;hello&apos;&gt;&gt;&gt; b = &apos;world&apos;&gt;&gt;&gt; c = cmp(a,b)&gt;&gt;&gt; c-1&gt;&gt;&gt; cmp(&apos;a&apos;,&apos;A&apos;)1&gt;&gt;&gt; cmp(&apos;a&apos;,&apos;b&apos;)-1&gt;&gt;&gt; cmp(&apos;a&apos;,&apos;a&apos;)0&gt;&gt;&gt; ord(&apos;a&apos;) //返回字符对应的ASCII码97&gt;&gt;&gt; ord(&apos;A&apos;)65&gt;&gt;&gt; 前者小，返回-1，前者大，返回1，一样大，返回0 random123456789101112131415161718192021222324252627&gt;&gt;&gt; import random&gt;&gt;&gt; blist=[random.randint(1,20) for i in range(10)]&gt;&gt;&gt; blist[3, 14, 1, 15, 16, 13, 9, 8, 10, 3]&gt;&gt;&gt; 数字字符串转换&gt;&gt;&gt; blist=[random.randint(1,20) for i in range(10)]&gt;&gt;&gt; blist[3, 14, 1, 15, 16, 13, 9, 8, 10, 3]&gt;&gt;&gt; clist=[str(e) for e in blist] &gt;&gt;&gt; clist[&apos;3&apos;, &apos;14&apos;, &apos;1&apos;, &apos;15&apos;, &apos;16&apos;, &apos;13&apos;, &apos;9&apos;, &apos;8&apos;, &apos;10&apos;, &apos;3&apos;]&gt;&gt;&gt; &apos;&apos;.join(clist)&apos;314115161398103&apos;&gt;&gt;&gt; &apos;-&apos;.join(clist)&apos;3-14-1-15-16-13-9-8-10-3&apos;&gt;&gt;&gt; &apos;*&apos;.join(clist)&apos;3*14*1*15*16*13*9*8*10*3&apos;&gt;&gt;&gt; 浮点类型&gt;&gt;&gt; dlist=[1.2,12.3,4.0,5.5&gt;&gt;&gt; elist=[ &apos;%.2f&apos; % e for e in dlist]&gt;&gt;&gt; elist[&apos;1.20&apos;, &apos;12.30&apos;, &apos;4.00&apos;, &apos;5.50&apos;]&gt;&gt;&gt; &apos;*&apos;.join(elist)&apos;1.20*12.30*4.00*5.50&apos;&gt;&gt;&gt; enumerate()enumnrate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。1234&gt;&gt;&gt; seasons = [&apos;Spring&apos;, &apos;Summer&apos;, &apos;Fall&apos;, &apos;Winter&apos;]&gt;&gt;&gt; list(enumerate(seasons))[(0, &apos;Spring&apos;), (1, &apos;Summer&apos;), (2, &apos;Fall&apos;), (3, &apos;Winter&apos;)]&gt;&gt;&gt; sorted() max() min() sum()12345678910111213&gt;&gt;&gt; tmplist[6, 19, 1, 19, 16, 1, 15, 7, 1, 18]&gt;&gt;&gt; max(tmplist)19&gt;&gt;&gt; min(tmplist)1&gt;&gt;&gt; sorted(tmplist)[1, 1, 1, 6, 7, 15, 16, 18, 19, 19]&gt;&gt;&gt; sorted(tmplist,reverse=True)[19, 19, 18, 16, 15, 7, 6, 1, 1, 1]&gt;&gt;&gt;&gt; 计算平均值sum(tmplist) / len(tmplist) zip zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。123456789101112131415161718192021&gt;&gt;&gt; aalist=[1,2,3,4]&gt;&gt;&gt; bblist=[5,6,7,8]&gt;&gt;&gt; zip(aalist,bblist)[(1, 5), (2, 6), (3, 7), (4, 8)]&gt;&gt;&gt; bblist=[5,6,7]&gt;&gt;&gt; zip(aalist,bblist)[(1, 5), (2, 6), (3, 7)]&gt;&gt;&gt; &gt;&gt;&gt; aalist=[1,2,3,4,5,6]&gt;&gt;&gt; zip(aalist[:-1],aalist[1:])[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]&gt;&gt;&gt; 转矩阵&gt;&gt;&gt; a=[1,2,3]&gt;&gt;&gt; b=[4,5,6]&gt;&gt;&gt; c=zip(a,b)&gt;&gt;&gt; c[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(*c)[(1, 2, 3), (4, 5, 6)]&gt;&gt;&gt; strip() Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。123456789101112131415&gt;&gt;&gt; &apos; hahaha &apos;&apos; hahaha &apos;&gt;&gt;&gt; &apos; hahaha &apos;.strip() //去除首尾空格&apos;hahaha&apos;&gt;&gt;&gt; &apos; hahaha &apos;.rstrip() //去除尾部空格&apos; hahaha&apos;&gt;&gt;&gt; &apos; hahaha &apos;.lstrip() //去除头部空格&apos;hahaha &apos;&gt;&gt;&gt; &gt;&gt;&gt; str=&apos;hello&apos;&gt;&gt;&gt; str.strip(&apos;o&apos;)&apos;hell&apos;&gt;&gt;&gt; str.strip(&apos;h&apos;)&apos;ello&apos;&gt;&gt;&gt; upper() lower()123456&gt; 大小写转换&gt;&gt;&gt; &apos;suiyue&apos;.upper()&apos;SUIYUE&apos;&gt;&gt;&gt; &apos;suiyue&apos;.lower()&apos;suiyue&apos;&gt;&gt;&gt; center()dir(‘’)help(‘’.center) //查看帮助123456789打印菱形#!/usr/bin/python2for i in range(1,5): print &quot;\n&quot;, print (&apos;* &apos; * (2 * i - 1)).center(39)for i in range(5,0,-1): print &quot;\n&quot;, print (&apos;* &apos; * (2*i-1)).center(39) bool()12345678910&gt;&gt;&gt; &gt;&gt;&gt; bool(-1)True&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(0.0)False&gt;&gt;&gt; split() splitlines()12345678910split()切割字符串&gt;&gt;&gt; str=&quot;root:passwd:3234:fdfa refg:ewfs&quot;&gt;&gt;&gt; str.split();[&apos;root:passwd:3234:fdfa&apos;, &apos;refg:ewfs&apos;]&gt;&gt;&gt; str.split(&apos;:&apos;);[&apos;root&apos;, &apos;passwd&apos;, &apos;3234&apos;, &apos;fdfa refg&apos;, &apos;ewfs&apos;]&gt;&gt;&gt; str.split(&apos;:&apos;,2); [&apos;root&apos;, &apos;passwd&apos;, &apos;3234:fdfa refg:ewfs&apos;]&gt;&gt;&gt; splitlines()切割语句 swapcase()交换大小写1234&gt;&gt;&gt; b=&apos;fasdf&apos;&gt;&gt;&gt; b.swapcase()&apos;FASDF&apos;&gt;&gt;&gt; map()1234567891011121314151617&gt; map() 会根据提供的函数对指定序列做映射。第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。 &gt;&gt;&gt; map(square, [1,2,3,4,5]) # 计算列表各个元素的平方[1, 4, 9, 16, 25]&gt;&gt;&gt; map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数[1, 4, 9, 16, 25]使源数据增加一点五倍&gt;&gt;&gt; results=map((lambda x+(0.5*x)),[1,2,3,4]) File &quot;&lt;stdin&gt;&quot;, line 1 results=map((lambda x+(0.5*x)),[1,2,3,4]) ^SyntaxError: invalid syntax&gt;&gt;&gt; results=map((lambda x:x+(0.5*x)),[1,2,3,4])&gt;&gt;&gt; results[1.5, 3.0, 4.5, 6.0]&gt;&gt;&gt; set() 去除列表重复元素12345678910111213141516171819202122232425&gt;&gt;&gt; a=[&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;a&apos;,&apos;c&apos;,&apos;b&apos;]&gt;&gt;&gt; b=list(set(a))&gt;&gt;&gt; b[&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;d&apos;]###### 顺序不变&gt;&gt;&gt; b.sort(key=a.index)&gt;&gt;&gt; b[&apos;a&apos;, &apos;b&apos;, &apos;d&apos;, &apos;c&apos;]&gt;&gt;&gt; #### 查看重复元素&gt;&gt;&gt; a=[&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;a&apos;,&apos;c&apos;,&apos;b&apos;]&gt;&gt;&gt; b=set(a)&gt;&gt;&gt; bset([&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;d&apos;])&gt;&gt;&gt; for i in b:... print &quot;the %s is found %d&quot; %(i,a.count(i))... the a is found 2the c is found 1the b is found 2the d is found 1&gt;&gt;&gt; pop()方法123456789101112131415&gt; pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值,原列表缩短&gt;&gt;&gt; b[&apos;user1&apos;, &apos;user2&apos;, &apos;user3&apos;, &apos;user5&apos;, &apos;user6&apos;, &apos;user7&apos;, &apos;user8&apos;, &apos;user9&apos;, &apos;user10&apos;, &apos;user11&apos;, &apos;user12&apos;, &apos;user13&apos;, &apos;user14&apos;, &apos;user15&apos;, &apos;user16&apos;, &apos;user17&apos;, &apos;user18&apos;, &apos;user19&apos;, &apos;user20&apos;, &apos;user21&apos;, &apos;user22&apos;, &apos;user23&apos;, &apos;user24&apos;, &apos;user25&apos;, &apos;user26&apos;, &apos;user27&apos;, &apos;user28&apos;, &apos;user29&apos;, &apos;user30&apos;, &apos;user31&apos;, &apos;user32&apos;, &apos;user33&apos;, &apos;user34&apos;, &apos;user35&apos;, &apos;user36&apos;, &apos;user37&apos;, &apos;user38&apos;, &apos;user39&apos;, &apos;user40&apos;]&gt;&gt;&gt; len(b)39&gt;&gt;&gt; for i in range(3):... b.pop()... &apos;user40&apos;&apos;user39&apos;&apos;user38&apos;&gt;&gt;&gt; len(b)36&gt;&gt;&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python变量]]></title>
    <url>%2F2018%2F09%2F11%2Fpython%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[在内存中存储的数据可以有多种类型，Python有五个标准的数据类型： Numbers(数字) String（字符串） List（列表） Tuple（元组） Dictionary（字典） 其中属于集合类型的数据类型有 列表、元组及字典 变量赋值 Python 中的变量赋值不需要类型声明每个变量在内存中创建，都包括变量的标识，名称和数据这些信息，每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。等号（=）用来给变量赋值，等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值** 多个变量赋值Python允许你同时为多个变量赋值。 例如：a = b = c = 1以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。也可以为多个对象指定多个变量。 例如：a, b, c = 1, 2, “john”以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。 Python数字四种不同的数字类型： int（有符号整型） long（长整型[也可以代表八进制和十六进制]） float（浮点型） complex（复数） 下面详细介绍 int（整型）在32位机器上，整数的位数为32位，取值范围为-231～231-1，即-2147483648～2147483647 在64位系统上，整数的位数为64位，取值范围为-263～263-1，即-9223372036854775808～9223372036854775807 long（长整型）跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，长整数数值不可能无限大。 ++注意，自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了++ *float（浮点型）浮点数用来处理实数，即带有小数的数字。类似于C语言中的double类型，占8个字节（64位），其中52位表示底，11位表示指数，剩下的一位表示符号。 complex（复数）复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数。 加减乘除123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; num = 1&gt;&gt;&gt; print num1&gt;&gt;&gt; num = 345.3453&gt;&gt;&gt; print &quot;num is %d&quot; % numnum is 345&gt;&gt;&gt; print &quot;num is %f&quot; % numnum is 345.345300&gt;&gt;&gt; print &quot;num is %.2f&quot; % numnum is 345.35&gt;&gt;&gt; print &quot;num is %.4f&quot; % numnum is 345.3453&gt;&gt;&gt; num1 = 34&gt;&gt;&gt; num / 2172.67265&gt;&gt;&gt; num1 / 217&gt;&gt;&gt; num = 34&gt;&gt;&gt; num / 311&gt;&gt;&gt; num / 3.011.333333333333334&gt;&gt;&gt; 34 ** 23167500108222301408246337399112597504L&gt;&gt;&gt; 34 - 56-22&gt;&gt;&gt; del num&gt;&gt;&gt; del num1浮点数精确计算&gt;&gt;&gt;from decimal import Decimal&gt;&gt;&gt;a = Decimal(&apos;3.2&apos;)&gt;&gt;&gt;b = Decimal(&apos;2.1&apos;)&gt;&gt;&gt;print(a + b) 进制转换 十进制转二进制 123&gt;&gt;&gt; bin(22) &apos;0b10110&apos;&gt;&gt;&gt; bin 十进制转十六进制 12&gt;&gt;&gt; hex(345) &apos;0x159&apos; 二进制，十六进制转十进制 1234&gt;&gt;&gt;int(&apos;1010111&apos;,2) 174&gt;&gt;&gt; int(&apos;0xf&apos;,16) 15 二进制转十六进制和十六进制转二进制 1234567&gt;&gt;&gt; hex(int(&apos;1010111&apos;,2))&apos;0x57&apos;&gt;&gt;&gt;&gt;&gt;&gt; bin(int(&apos;ff&apos;,16))&apos;0b11111111&apos;&gt;&gt;&gt; Python字符串字符串或串(String)是由数字、字母、下划线组成的一串字符python的字串列表有2种取值顺序: 从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头 从字符串中获取一段子字符串，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 截取字符串：注意：一定要搞清楚下标是从0开始的，列表右边的元素是不被包含的，而且字符串打印方向默认从左向右，跳数为负则表示向左。 12345678910111213141516171819202122&gt;&gt;&gt; astr = &quot;abcdefg&quot;&gt;&gt;&gt; astr[:]&apos;abcdefg&apos;&gt;&gt;&gt; astr[2]&apos;c&apos;&gt;&gt;&gt; astr[0:6]&apos;abcdef&apos;&gt;&gt;&gt; astr = &quot;abcdefgh&quot;&gt;&gt;&gt; astr&apos;abcdefgh&apos;&gt;&gt;&gt; astr[2]&apos;c&apos;&gt;&gt;&gt; astr[2:6]&apos;cdef&apos;&gt;&gt;&gt; astr[2:]&apos;cdefgh&apos;&gt;&gt;&gt; print astr *4abcdefghabcdefghabcdefghabcdefgh&gt;&gt;&gt; print astr + &quot;!!hello&quot;abcdefgh!!hello&gt;&gt;&gt; print [astr] * 2[&apos;abcdefgh&apos;, &apos;abcdefgh&apos;] 1234567891011121314151617181920212223&gt;&gt;&gt; astr = &apos;123456789&apos;&gt;&gt;&gt; astr[0:2]&apos;12&apos;&gt;&gt;&gt; astr[0::2]&apos;13579&apos;&gt;&gt;&gt; astr[1::2]&apos;2468&apos;&gt;&gt;&gt; astr[::-1]&apos;987654321&apos;&gt;&gt;&gt; astr[1::-1]&apos;21&apos;&gt;&gt;&gt; astr[4::-1]&apos;54321&apos;&gt;&gt;&gt; astr[::]&apos;123456789&apos;&gt;&gt;&gt; astr[::1]&apos;123456789&apos;&gt;&gt;&gt; astr[::3]&apos;147&apos;&gt;&gt;&gt; astr[0::3]&apos;147&apos;&gt;&gt;&gt; astr[1::3]&apos;258&apos; 以上综述：123451. astr[1::-1] 表示打印下标1到下标0的元素,-1表示的是跳数1. astr[::-1] 表示逆序打印所有元素1. astr[0::-1] 表示打印下标0的元素1. astr[-5::2] 表示从倒数第5个开始，向右每隔一个元素打印2. satr[-2::-2] 表示从倒数第二个元素开始，向左每隔一个元素打印一个 Python列表 List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用 [ ] 标识，是 python 最通用的复合数据类型。列表中值的切割也可以用到变量[头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。 列表简单操作 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; list = [&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; tinylist = [&apos;world&apos;, 567]&gt;&gt;&gt; print list[&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; print (&quot;list&quot;)list&gt;&gt;&gt; list = [&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; print (&quot;list&quot;)list&gt;&gt;&gt; list = [&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; tinylist = [&apos;world&apos;, 567]&gt;&gt;&gt; print (list)[&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; print (list[2])wel&gt;&gt;&gt; print (list[0:2])[&apos;hello&apos;, &apos;tom&apos;]&gt;&gt;&gt; print (list[::-1])[999, &apos;wel&apos;, &apos;tom&apos;, &apos;hello&apos;]&gt;&gt;&gt; print (list[2::-1])[&apos;wel&apos;, &apos;tom&apos;, &apos;hello&apos;]&gt;&gt;&gt; print (list[3::-1])[999, &apos;wel&apos;, &apos;tom&apos;, &apos;hello&apos;]&gt;&gt;&gt; print (list[::2])[&apos;hello&apos;, &apos;wel&apos;]&gt;&gt;&gt; print (list[::3])[&apos;hello&apos;, 999]&gt;&gt;&gt; print (list[1::2])[&apos;tom&apos;, 999] 生成列表快速方法：1234&gt;&gt;&gt; pystr=&apos;python&apos;&gt;&gt;&gt; list(pystr)[&apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]&gt;&gt;&gt; Python元组 元组是另一个数据类型，类似于List（列表）。元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; tuple(&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[1]786&gt;&gt;&gt; tuple[1::2](786, &apos;john&apos;)&gt;&gt;&gt; tuple[0::2](&apos;runoob&apos;, 2.23, 70.2)&gt;&gt;&gt; tuple[-4::1] 表示打印下标从-4到1的元素(786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[-4::-1] 表示打印下标从-4到-5的元素，-1不仅表示跳数，还表示打印方向从右向左(786, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-1::-2] 表示打印下标从-1到-5并且跳2个元素(70.2, 2.23, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-1::-1](70.2, &apos;john&apos;, 2.23, 786, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-5::] (&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[-5::-2] (&apos;runoob&apos;,)&gt;&gt;&gt; tuple[-5::-1](&apos;runoob&apos;,)&gt;&gt;&gt; tuple[-1:-4:-1] 表示打印下标从-1到-4挨个打印的元素，是逆序(70.2, &apos;john&apos;, 2.23)&gt;&gt;&gt; tuple[-5::](&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[-5::2](&apos;runoob&apos;, 2.23, 70.2)&gt;&gt;&gt; tuple[-3::-1](2.23, 786, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-3::1](2.23, &apos;john&apos;, 70.2) Python 字典 字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 字典简单操作 1234567891011121314&gt;&gt;&gt; dict = &#123;&#125;&gt;&gt;&gt; dict[&apos;one&apos;] = &quot;this is one&quot;&gt;&gt;&gt; dict[2] = &quot;this is two&quot;&gt;&gt;&gt; print dict[&apos;one&apos;]this is one&gt;&gt;&gt; print dict[2]this is two&gt;&gt;&gt; dict1 = &#123;&apos;name&apos;: &apos;xiao&apos;,&apos;age&apos;: &apos;22&apos;,&apos;dept&apos;: &apos;sales&apos;&#125;&gt;&gt;&gt; print dict1&#123;&apos;dept&apos;: &apos;sales&apos;, &apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;xiao&apos;&#125;&gt;&gt;&gt; print dict1.keys()[&apos;dept&apos;, &apos;age&apos;, &apos;name&apos;]&gt;&gt;&gt; print dict1.values()[&apos;sales&apos;, &apos;22&apos;, &apos;xiao&apos;] raw_input() raw_input函数，用来获取控制台的输入，并且将所有输入看做字符串，返回字符串类型 123456789101112131415编辑脚本 hello.py vim hello.py #!/usr/bin/python2name = raw_input(&apos;PLS input your usernmae: &apos;) age = raw_input(&apos;PLS input your age: &apos;) print &quot; you name %s you are %d age&quot; % (name,int(age))运行测试[root@suiyuewuheng python]# python hello.py PLS input your usernmae: xiaoPLS input your age: 22 you name xiao you are 22 age[root@suiyuewuheng python]# 这里要记得将age变量类型进项转换，不然会报语法错误 结合列表作个测试： 123456789101112&gt;&gt;&gt; list1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,raw_input] &gt;&gt;&gt; list[-1] 999 &gt;&gt;&gt; list1[-1] &lt;built-in function raw_input&gt; &gt;&gt;&gt; list1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,raw_input] &gt;&gt;&gt; list1[-1] &lt;built-in function raw_input&gt; &gt;&gt;&gt; list1[-1](&apos;pls input your passwd: &apos;) pls input your passwd: redhat &apos;redhat&apos; &gt;&gt;&gt; Python变量++ 注意python中有可变对象和不可变对象，可变对象：list,dict.不可变对象有:int,string,float,tuple。 不可变对象类型：有i和j俩个变量的值为77，通过打印77的ID和变量i，j在内存中的id我们得知它们都是指向同一块内存。所以说i和j都是指向同一个对象的。然后我们修改j的值，让j的值+1.按道理j修改之后应该i的值也发生改变的，因为它们都是指向的同一块内存，但结果是并没有。因为int类型是不可变类型，所有其实是j复制了一份到新的内存地址然后+1，然后j又指向了新的地址。所以j的内存id发生了变化。123456789&gt;&gt;&gt; def add(num):... num=num+1... return num... &gt;&gt;&gt; a=1&gt;&gt;&gt; add(a)2&gt;&gt;&gt; print a1 可变对象类型123456789101112131415161718192021测试：def dict_test(): a = &#123;&#125; b = a print(id(a)) a[&apos;a&apos;] = &apos;hhhh&apos; print(&apos;id a:&apos; + str(id(a))) print(&apos;a:&apos; + str(a)) print(&apos;id b:&apos; + str(id(b))) print(&apos;b:&apos; + str(b)) 运行结果：140367329543360id a:140367329543360a:&#123;&apos;a&apos;: &apos;hhhh&apos;&#125;id b:140367329543360b:&#123;&apos;a&apos;: &apos;hhhh&apos;&#125; 可以看到a最早的内存地址id是140367329543360 然后把a赋值给b其实就是让变量b的也指向a所指向的内存空间。然后我们发现当a发生变化后，b也跟着发生变化了，因为list是可变类型，所以并不会复制一份再改变，而是直接在a所指向的内存空间修改数据，而b也是指向该内存空间的，自然b也就跟着改变了。 在 python 中，类型属于对象，变量是没有类型的：a=[1,2,3]a=”Runoob”以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。 全局变量与局部变量123456789101112131415161718&gt; 局部变量:#!/usr/bin/python2#encoding:utf-8x=12def func(x): print &quot;全局x=&quot; ,x x=1 print &quot;局部x=&quot; ,xfunc(x)print &quot;全局x=&quot; ,x运行结果:[root@suiyuewuheng python]# python jubu.py 全局x= 12局部x= 1全局x= 12[root@suiyuewuheng python]# 1234567891011121314151617181920&gt; 全局变量#!/usr/bin/python2#encoding:utf-8x=12def func(): global x //声明是全局变量 print &quot;全局x=&quot; ,x x=1 print &quot;局部x=&quot; ,xfunc()print &quot;全局x=&quot; ,x&gt; 运行结果:[root@suiyuewuheng python]# vim jubu.py [root@suiyuewuheng python]# python jubu.py 全局x= 12局部x= 1全局x= 1]]></content>
  </entry>
  <entry>
    <title><![CDATA[软链接与硬链接]]></title>
    <url>%2F2018%2F09%2F10%2F%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[概述 在Linux系统中,内核为每一个新创建的文件分配一个Inode(索引结点),每个文件都有一个惟一的inode号。文件属性保存在索引结点里，在访问文件时，索引结点被复制到内存在，从而实现文件的快速访问。链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的一种方法。Linux中包括两种链接：硬链接(Hard Link)和软链接(Soft Link),软链接又称为符号链接（Symbolic link）。符号连接相当于Windows下的快捷方式。 硬链接 语法： ln src-file dst-file 硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。可以用:ln命令来建立硬链接 123456789101112131415mkdir new &amp;&amp; echo &quot;this is new file&quot; &gt; new/own.filecd /newln own.file &gt; hardls -l[root@suiyuewuheng new]# ls -ltotal 8-rw-r--r-- 2 root root 17 Sep 10 11:27 hard-rw-r--r-- 2 root root 17 Sep 10 11:27 own.file[root@suiyuewuheng new]# cat hard this is new file[root@suiyuewuheng new]# rm -rf *[root@suiyuewuheng new]# mkdir file.dr[root@suiyuewuheng new]# ln file.dir file.dir.handln: failed to access ‘file.dir’: No such file or directory[root@suiyuewuheng new]# 从上我们可以看到，两个文件有相同的inode值和文件属性，它们指向的都是同一个区块，查看文件内容，两个文件也一模一样，说白了硬链接是一个指针，指向文件索引节点，系统并不为它重新分配inode，建立file的硬链接就是为file的文件索引节点在当前目录上建立一个新指针，删除其中任何一个文件，链接数会减一，当所有链接文件都被删除时（也就是当链接数减到零时），文件就会从磁盘上删除 硬链接不足： 不可以在不同文件系统的文件间建立链接 只有超级用户才可以为目录创建硬链接 不能为目录创建硬链接 软链接 语法：ls -s src.file dst.file 软链接类似windows下的快捷方式，它实际上是一个特殊的文件，在软连接中，软连接文件实际上就是一个文本文件，这个文件中包含有软链接指向另一个文件的文职信息内容，因此，通过访问这个“快捷方式”就可以迅速定位到软链接所指向的源文件实体。 12345678910111213[root@suiyuewuheng new]# touch file1[root@suiyuewuheng new]# ln -s file1 file1.soft[root@suiyuewuheng new]# mkdir file1.dir[root@suiyuewuheng new]# ln -s file1.dir file1.dir.soft[root@suiyuewuheng new]# ln file1.dir file1.dir.handln: ‘file1.dir’: hard link not allowed for directory[root@suiyuewuheng new]# ls -litotal 42490370 -rw-r--r-- 1 root root 0 Sep 10 12:22 file12490372 drwxr-xr-x 2 root root 4096 Sep 10 12:22 file1.dir2490373 lrwxrwxrwx 1 root root 9 Sep 10 12:23 file1.dir.soft -&gt; file1.dir2490371 lrwxrwxrwx 1 root root 5 Sep 10 12:22 file1.soft -&gt; file1[root@suiyuewuheng new]# 可以看到，软链接具有和源文件不同的inode节点值，它们是不同的文件，在文件属性上软链接明确写出了是链接文件，而硬链接没有写出来，因为在本质上硬链接文件和原文件是完全平等关系，第三列是文件链接数或者目录子目录数，file1.dir的目录子目录数没有增加，还是2，这个表示该目录下有两个子目录. 和 .. ,file1的文件链接数也咩有增加，第六列是文件大小，也不相同，file1是0B，而file1.soft是5B，这里的5B其实就是file1的大小，软链接可以指向目录，而硬链接不能指向目录。当删除源文件时，软链接文件随即消失。 总之，建立软链接就是建立了一个新文件。当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。 - [ ] 软链接不足 移动源文件，可能会导致软链接文件失效，无法找到源文件 消耗系统inode节点数和分配路径所需空间]]></content>
  </entry>
</search>
