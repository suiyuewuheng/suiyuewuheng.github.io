<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python变量]]></title>
    <url>%2F2018%2F09%2F11%2Fpython%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[在内存中存储的数据可以有多种类型，Python有五个标准的数据类型： Numbers(数字) String（字符串） List（列表） Tuple（元组） Dictionary（字典） 其中属于集合类型的数据类型有 列表、元组及字典 变量赋值 Python 中的变量赋值不需要类型声明每个变量在内存中创建，都包括变量的标识，名称和数据这些信息，每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。等号（=）用来给变量赋值，等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值** 多个变量赋值Python允许你同时为多个变量赋值。 例如：a = b = c = 1以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。也可以为多个对象指定多个变量。 例如：a, b, c = 1, 2, “john”以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。 Python数字四种不同的数字类型： int（有符号整型） long（长整型[也可以代表八进制和十六进制]） float（浮点型） complex（复数） 下面详细介绍 int（整型）在32位机器上，整数的位数为32位，取值范围为-231～231-1，即-2147483648～2147483647 在64位系统上，整数的位数为64位，取值范围为-263～263-1，即-9223372036854775808～9223372036854775807 long（长整型）跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，长整数数值不可能无限大。 ++注意，自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了++ *float（浮点型）浮点数用来处理实数，即带有小数的数字。类似于C语言中的double类型，占8个字节（64位），其中52位表示底，11位表示指数，剩下的一位表示符号。 complex（复数）复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数。 加减乘除12345678910111213141516171819202122232425262728&gt;&gt;&gt; num = 1&gt;&gt;&gt; print num1&gt;&gt;&gt; num = 345.3453&gt;&gt;&gt; print &quot;num is %d&quot; % numnum is 345&gt;&gt;&gt; print &quot;num is %f&quot; % numnum is 345.345300&gt;&gt;&gt; print &quot;num is %.2f&quot; % numnum is 345.35&gt;&gt;&gt; print &quot;num is %.4f&quot; % numnum is 345.3453&gt;&gt;&gt; num1 = 34&gt;&gt;&gt; num / 2172.67265&gt;&gt;&gt; num1 / 217&gt;&gt;&gt; num = 34&gt;&gt;&gt; num / 311&gt;&gt;&gt; num / 3.011.333333333333334&gt;&gt;&gt; 34 ** 23167500108222301408246337399112597504L&gt;&gt;&gt; 34 - 56-22&gt;&gt;&gt; del num&gt;&gt;&gt; del num1 进制转换 十进制转二进制 123&gt;&gt;&gt; bin(22) &apos;0b10110&apos;&gt;&gt;&gt; bin 十进制转十六进制 12&gt;&gt;&gt; hex(345) &apos;0x159&apos; 二进制，十六进制转十进制 1234&gt;&gt;&gt;int(&apos;1010111&apos;,2) 174&gt;&gt;&gt; int(&apos;0xf&apos;,16) 15 二进制转十六进制和十六进制转二进制 1234567&gt;&gt;&gt; hex(int(&apos;1010111&apos;,2))&apos;0x57&apos;&gt;&gt;&gt;&gt;&gt;&gt; bin(int(&apos;ff&apos;,16))&apos;0b11111111&apos;&gt;&gt;&gt; Python字符串字符串或串(String)是由数字、字母、下划线组成的一串字符python的字串列表有2种取值顺序: 从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头 从字符串中获取一段子字符串，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 截取字符串：注意：一定要搞清楚下标是从0开始的，列表右边的元素是不被包含的，而且字符串打印方向默认从左向右，跳数为负则表示向左。 12345678910111213141516171819202122&gt;&gt;&gt; astr = &quot;abcdefg&quot;&gt;&gt;&gt; astr[:]&apos;abcdefg&apos;&gt;&gt;&gt; astr[2]&apos;c&apos;&gt;&gt;&gt; astr[0:6]&apos;abcdef&apos;&gt;&gt;&gt; astr = &quot;abcdefgh&quot;&gt;&gt;&gt; astr&apos;abcdefgh&apos;&gt;&gt;&gt; astr[2]&apos;c&apos;&gt;&gt;&gt; astr[2:6]&apos;cdef&apos;&gt;&gt;&gt; astr[2:]&apos;cdefgh&apos;&gt;&gt;&gt; print astr *4abcdefghabcdefghabcdefghabcdefgh&gt;&gt;&gt; print astr + &quot;!!hello&quot;abcdefgh!!hello&gt;&gt;&gt; print [astr] * 2[&apos;abcdefgh&apos;, &apos;abcdefgh&apos;] 1234567891011121314151617181920212223&gt;&gt;&gt; astr = &apos;123456789&apos;&gt;&gt;&gt; astr[0:2]&apos;12&apos;&gt;&gt;&gt; astr[0::2]&apos;13579&apos;&gt;&gt;&gt; astr[1::2]&apos;2468&apos;&gt;&gt;&gt; astr[::-1]&apos;987654321&apos;&gt;&gt;&gt; astr[1::-1]&apos;21&apos;&gt;&gt;&gt; astr[4::-1]&apos;54321&apos;&gt;&gt;&gt; astr[::]&apos;123456789&apos;&gt;&gt;&gt; astr[::1]&apos;123456789&apos;&gt;&gt;&gt; astr[::3]&apos;147&apos;&gt;&gt;&gt; astr[0::3]&apos;147&apos;&gt;&gt;&gt; astr[1::3]&apos;258&apos; 以上综述：123451. astr[1::-1] 表示打印下标1到下标0的元素,-1表示的是跳数1. astr[::-1] 表示逆序打印所有元素1. astr[0::-1] 表示打印下标0的元素1. astr[-5::2] 表示从倒数第5个开始，向右每隔一个元素打印2. satr[-2::-2] 表示从倒数第二个元素开始，向左每隔一个元素打印一个 截取特定字符串find方法可以在一个较长的字符串中查找子字符串。它返回子串所在位置的最左端索引。如果没有找到则返回-11234&gt;&gt;&gt; a = &apos;test&apos;&gt;&gt;&gt; a.find(&apos;s&apos;)2&gt;&gt;&gt; find方法其实和列表取步长的方法联用来截取某段需要的字符串。12345&gt;&gt;&gt; a = &quot;i want my tears back&quot;&gt;&gt;&gt; b = a[a.find(&apos;w&apos;):a.find(&apos;s&apos;)]&gt;&gt;&gt; b&apos;want my tear&apos;&gt;&gt;&gt; join123456join方法是非常重要的字符串方法，它是split方法的逆方法，用来在队列中添加元素。注意：需要添加的队列元素都必须是字符串。&gt;&gt;&gt; test = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]&gt;&gt;&gt; out = &apos;+&apos;.join(test)&gt;&gt;&gt; out&apos;a+b+c+d&apos; replacereplace方法返回某个字符串的所有匹配项均被替换之后得到的字符串。12345678910111213141516&gt;&gt;&gt; a = &apos;hello world&apos;&gt;&gt;&gt; b = a.replace(&apos;r&apos;,&apos;l&apos;)&gt;&gt;&gt; b&apos;hello wolld&apos;&gt;&gt;&gt;&gt;&gt;&gt; a&apos;dsaasdfa0&apos;&gt;&gt;&gt; b=a.replace(&apos;a&apos;,&apos;s&apos;,2)&gt;&gt;&gt; b&apos;dssssdfa0&apos;&gt;&gt;&gt; b=a.replace(&apos;a&apos;,&apos;s&apos;,1)&gt;&gt;&gt; b&apos;dssasdfa0&apos;&gt;&gt;&gt; 其中2,1表示替换字符不超过2,1次 len 字符串长度获取12345&gt;&gt;&gt; a = &apos;hello world&apos;&gt;&gt;&gt; b = len(a)&gt;&gt;&gt; b11&gt;&gt;&gt; 连接字符串123456&gt;&gt;&gt; a=&apos;dsfa&apos;&gt;&gt;&gt; b=&apos;&apos;&gt;&gt;&gt; c=&apos;sd&apos;&gt;&gt;&gt; a+b+c&apos;dsfasd&apos;&gt;&gt;&gt; cmp 比较字符串123456&gt;&gt;&gt; a = &apos;hello&apos;&gt;&gt;&gt; b = &apos;world&apos;&gt;&gt;&gt; c = cmp(a,b)&gt;&gt;&gt; c-1&gt;&gt;&gt; Python列表 List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用 [ ] 标识，是 python 最通用的复合数据类型。列表中值的切割也可以用到变量[头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。 列表简单操作 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; list = [&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; tinylist = [&apos;world&apos;, 567]&gt;&gt;&gt; print list[&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; print (&quot;list&quot;)list&gt;&gt;&gt; list = [&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; print (&quot;list&quot;)list&gt;&gt;&gt; list = [&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; tinylist = [&apos;world&apos;, 567]&gt;&gt;&gt; print (list)[&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; print (list[2])wel&gt;&gt;&gt; print (list[0:2])[&apos;hello&apos;, &apos;tom&apos;]&gt;&gt;&gt; print (list[::-1])[999, &apos;wel&apos;, &apos;tom&apos;, &apos;hello&apos;]&gt;&gt;&gt; print (list[2::-1])[&apos;wel&apos;, &apos;tom&apos;, &apos;hello&apos;]&gt;&gt;&gt; print (list[3::-1])[999, &apos;wel&apos;, &apos;tom&apos;, &apos;hello&apos;]&gt;&gt;&gt; print (list[::2])[&apos;hello&apos;, &apos;wel&apos;]&gt;&gt;&gt; print (list[::3])[&apos;hello&apos;, 999]&gt;&gt;&gt; print (list[1::2])[&apos;tom&apos;, 999] 生成列表快速方法：1234&gt;&gt;&gt; pystr=&apos;python&apos;&gt;&gt;&gt; list(pystr)[&apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]&gt;&gt;&gt; Python元组 元组是另一个数据类型，类似于List（列表）。元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; tuple(&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[1]786&gt;&gt;&gt; tuple[1::2](786, &apos;john&apos;)&gt;&gt;&gt; tuple[0::2](&apos;runoob&apos;, 2.23, 70.2)&gt;&gt;&gt; tuple[-4::1](786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[-4::-1](786, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-1::-2](70.2, 2.23, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-1::-1](70.2, &apos;john&apos;, 2.23, 786, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-5::](&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[-5::-2](&apos;runoob&apos;,)&gt;&gt;&gt; tuple[-5::-1](&apos;runoob&apos;,)&gt;&gt;&gt; tuple[-5::](&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[-5::2](&apos;runoob&apos;, 2.23, 70.2)&gt;&gt;&gt; tuple[-3::-1](2.23, 786, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-3::1](2.23, &apos;john&apos;, 70.2) Python 字典 字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 字典简单操作 1234567891011121314&gt;&gt;&gt; dict = &#123;&#125;&gt;&gt;&gt; dict[&apos;one&apos;] = &quot;this is one&quot;&gt;&gt;&gt; dict[2] = &quot;this is two&quot;&gt;&gt;&gt; print dict[&apos;one&apos;]this is one&gt;&gt;&gt; print dict[2]this is two&gt;&gt;&gt; dict1 = &#123;&apos;name&apos;: &apos;xiao&apos;,&apos;age&apos;: &apos;22&apos;,&apos;dept&apos;: &apos;sales&apos;&#125;&gt;&gt;&gt; print dict1&#123;&apos;dept&apos;: &apos;sales&apos;, &apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;xiao&apos;&#125;&gt;&gt;&gt; print dict1.keys()[&apos;dept&apos;, &apos;age&apos;, &apos;name&apos;]&gt;&gt;&gt; print dict1.values()[&apos;sales&apos;, &apos;22&apos;, &apos;xiao&apos;] raw_input() raw_input函数，用来获取控制台的输入，并且将所有输入看做字符串，返回字符串类型 123456789101112131415编辑脚本 hello.py vim hello.py #!/usr/bin/python2name = raw_input(&apos;PLS input your usernmae: &apos;) age = raw_input(&apos;PLS input your age: &apos;) print &quot; you name %s you are %d age&quot; % (name,int(age))运行测试[root@suiyuewuheng python]# python hello.py PLS input your usernmae: xiaoPLS input your age: 22 you name xiao you are 22 age[root@suiyuewuheng python]# 这里要记得将age变量类型进项转换，不然会报语法错误 结合列表作个测试： 123456789101112&gt;&gt;&gt; list1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,raw_input] &gt;&gt;&gt; list[-1] 999 &gt;&gt;&gt; list1[-1] &lt;built-in function raw_input&gt; &gt;&gt;&gt; list1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,raw_input] &gt;&gt;&gt; list1[-1] &lt;built-in function raw_input&gt; &gt;&gt;&gt; list1[-1](&apos;pls input your passwd: &apos;) pls input your passwd: redhat &apos;redhat&apos; &gt;&gt;&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[软链接与硬链接]]></title>
    <url>%2F2018%2F09%2F10%2F%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[概述 在Linux系统中,内核为每一个新创建的文件分配一个Inode(索引结点),每个文件都有一个惟一的inode号。文件属性保存在索引结点里，在访问文件时，索引结点被复制到内存在，从而实现文件的快速访问。链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的一种方法。Linux中包括两种链接：硬链接(Hard Link)和软链接(Soft Link),软链接又称为符号链接（Symbolic link）。符号连接相当于Windows下的快捷方式。 硬链接 语法： ln src-file dst-file 硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。可以用:ln命令来建立硬链接 123456789101112131415mkdir new &amp;&amp; echo &quot;this is new file&quot; &gt; new/own.filecd /newln own.file &gt; hardls -l[root@suiyuewuheng new]# ls -ltotal 8-rw-r--r-- 2 root root 17 Sep 10 11:27 hard-rw-r--r-- 2 root root 17 Sep 10 11:27 own.file[root@suiyuewuheng new]# cat hard this is new file[root@suiyuewuheng new]# rm -rf *[root@suiyuewuheng new]# mkdir file.dr[root@suiyuewuheng new]# ln file.dir file.dir.handln: failed to access ‘file.dir’: No such file or directory[root@suiyuewuheng new]# 从上我们可以看到，两个文件有相同的inode值和文件属性，它们指向的都是同一个区块，查看文件内容，两个文件也一模一样，说白了硬链接是一个指针，指向文件索引节点，系统并不为它重新分配inode，建立file的硬链接就是为file的文件索引节点在当前目录上建立一个新指针，删除其中任何一个文件，链接数会减一，当所有链接文件都被删除时（也就是当链接数减到零时），文件就会从磁盘上删除 硬链接不足： 不可以在不同文件系统的文件间建立链接 只有超级用户才可以为目录创建硬链接 不能为目录创建硬链接 软链接 语法：ls -s src.file dst.file 软链接类似windows下的快捷方式，它实际上是一个特殊的文件，在软连接中，软连接文件实际上就是一个文本文件，这个文件中包含有软链接指向另一个文件的文职信息内容，因此，通过访问这个“快捷方式”就可以迅速定位到软链接所指向的源文件实体。 12345678910111213[root@suiyuewuheng new]# touch file1[root@suiyuewuheng new]# ln -s file1 file1.soft[root@suiyuewuheng new]# mkdir file1.dir[root@suiyuewuheng new]# ln -s file1.dir file1.dir.soft[root@suiyuewuheng new]# ln file1.dir file1.dir.handln: ‘file1.dir’: hard link not allowed for directory[root@suiyuewuheng new]# ls -litotal 42490370 -rw-r--r-- 1 root root 0 Sep 10 12:22 file12490372 drwxr-xr-x 2 root root 4096 Sep 10 12:22 file1.dir2490373 lrwxrwxrwx 1 root root 9 Sep 10 12:23 file1.dir.soft -&gt; file1.dir2490371 lrwxrwxrwx 1 root root 5 Sep 10 12:22 file1.soft -&gt; file1[root@suiyuewuheng new]# 可以看到，软链接具有和源文件不同的inode节点值，它们是不同的文件，在文件属性上软链接明确写出了是链接文件，而硬链接没有写出来，因为在本质上硬链接文件和原文件是完全平等关系，第三列是文件链接数或者目录子目录数，file1.dir的目录子目录数没有增加，还是2，这个表示该目录下有两个子目录. 和 .. ,file1的文件链接数也咩有增加，第六列是文件大小，也不相同，file1是0B，而file1.soft是5B，这里的5B其实就是file1的大小，软链接可以指向目录，而硬链接不能指向目录。当删除源文件时，软链接文件随即消失。 总之，建立软链接就是建立了一个新文件。当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。 - [ ] 软链接不足 移动源文件，可能会导致软链接文件失效，无法找到源文件 消耗系统inode节点数和分配路径所需空间]]></content>
  </entry>
</search>
