<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python-os模块]]></title>
    <url>%2F2018%2F09%2F28%2Fpython-os%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[文件系统操作库:os dir(os) 显示os库内置函数 help(os.mkdir)显示函数操作帮助 os.mkdir() [make directory] os.rmdir() [remove directory] os.getcwd()[current working directory] os.chdir() [change directory] os.rename() os.listdir() os.makedirs() os.removedirs()123456789101112131415161718192021&gt;&gt;&gt; os.mkdir(&apos;/tmp/e1&apos;)&gt;&gt;&gt; os.mkdir(&apos;/tmp/e2&apos;)&gt;&gt;&gt; &gt;&gt;&gt; os.rmdir(&apos;/tmp/e1&apos;)&gt;&gt;&gt; os.rmdir(&apos;/tmp/e2&apos;)&gt;&gt;&gt; &gt;&gt;&gt; os.getcwd()&apos;/var/python&apos;&gt;&gt;&gt; os.chdir(&apos;/var/python&apos;)&gt;&gt;&gt; os.getcwd()&apos;/var/python&apos;&gt;&gt;&gt; os.chdir(&apos;/tmp&apos;)&gt;&gt;&gt; os.getcwd()&apos;/tmp&apos;&gt;&gt;&gt; &gt;&gt;&gt; os.rename(&apos;ip_txt&apos;,&apos;ip2.txt&apos;)&gt;&gt;&gt; &gt;&gt;&gt; os.listdir(&apos;/var/python&apos;)[&apos;test.py&apos;, &apos;passwd.py&apos;, &apos;dic&apos;, &apos;sanjiao.py&apos;, &apos;jubu.py&apos; ]&gt;&gt;&gt; os.makedirs(&apos;/tmp/m1/m2/m3&apos;)&gt;&gt;&gt; os.removedirs(&apos;/tmp/m1/m2/m3&apos;) //删除m1/m2/m3文件夹 重点函数:os.walk()os.walk是一个简单易用的文件、目录遍历器os.walk的函数声明为:++walk(top, topdown=True, onerror=None, followlinks=False)++123456参数top 是你所要便利的目录的地址topdown 为真，则优先遍历top目录，否则优先遍历top的子目录(默认为开启)onerror 需要一个 callable 对象，当walk需要异常时，会调用followlinks 如果为真，则会遍历目录下的快捷方式(linux 下是 symbolic link)实际所指的目录(默认关闭)os.walk 的返回值是一个生成器(generator),也就是说我们需要不断的遍历它，来获得所有的内容 123456789101112131415161718192021222324创建目录:[root@suiyuewuheng /]# tree walklwalkl├── file1├── file2├── wa1│ ├── file3│ └── wawa1└── wa2开始遍历:&gt;&gt;&gt; wal=os.walk(&apos;/walkl&apos;)&gt;&gt;&gt; wal.next()(&apos;/walkl&apos;, [&apos;wa1&apos;, &apos;wa2&apos;], [&apos;file2&apos;, &apos;file1&apos;]) //从左至右依次是:路径 目录 文件&gt;&gt;&gt; wal.next()(&apos;/walkl/wa1&apos;, [&apos;wawa1&apos;], [&apos;file3&apos;])&gt;&gt;&gt; wal.next()(&apos;/walkl/wa1/wawa1&apos;, [], [])&gt;&gt;&gt; wal.next()(&apos;/walkl/wa2&apos;, [], [])&gt;&gt;&gt; wal.next()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 编写文件搜索脚本:12345678910111213141516171819#!/usr/bin/pythonimport osimport syspath=sys.argv[1]filename=sys.argv[2]for (curpath,subpath,files) in os.walk(path): for f in files: if filename == f print &quot;%s has the file %s&quot; % (curpath,filename)运行:[root@suiyuewuheng python]# python walk.py /etc sshd/etc/pam.d has the file sshd/etc/sysconfig has the file sshd[root@suiyuewuheng python]# python walk.py /walkl/ file3/walkl/wa1 has the file file3 列出目录下文件123456789101112#!/usr/bin/pythonimport osimport syspath=sys.argv[1]for (curpath,subpath,files) in os.walk(path): for f in files: print &quot;%s%s&quot; % (curpath,f)运行:[root@suiyuewuheng python]# python walk.py /var/python/ |grep passwd/var/python/passwd.py/var/python/passwd os.pathimport osimport os.path os.getsize() os.path.basename() os.path.dirname() 1234567891011121314&gt;&gt;&gt; os.path.getsize(&apos;/etc/passwd&apos;)1593&gt;&gt;&gt; &gt;&gt;&gt; os.path.basename(&apos;/etc/sysconfig/network-scripts/ifcfg-eth0&apos;)&apos;ifcfg-eth0&apos;&gt;&gt;&gt; &gt;&gt;&gt; os.path.dirname(&apos;/etc/sysconfig/network-scripts/ifcfg-eth0&apos;)&apos;/etc/sysconfig/network-scripts&apos;&gt;&gt;&gt; &gt;&gt;&gt; os.path.getatime(&apos;/etc/passwd&apos;)1537340950.5578592&gt;&gt;&gt; time.ctime(os.path.getatime(&apos;/etc/passwd&apos;))&apos;Wed Sep 19 15:09:10 2018&apos;&gt;&gt;&gt; 获取文件修改时间案例:12345678910111213141516171819202122#!/usr/bin/pythonimport osimport os.pathimport sysimport timepath=sys.argv[1]record_file=&apos;/tmp/record.txt&apos;fh=open(record_file,&apos;w+&apos;)for curpath,subpath,files in os.walk(path,followlinks=True): for f in files: filename=&quot;%s/%s&quot; %(curpath,f) content = &quot;%s:%s\n&quot; % (filename, str(time.ctime(os.path.getmtime(filename)))) fh.write(content)fh.close()运行:python shijian.py[root@suiyuewuheng python]# cat /tmp/record.txt /var/python/passwd.py:Wed Sep 12 15:39:16 2018/var/python/dic:Wed Sep 12 15:34:59 2018/var/python/sanjiao.py:Fri Sep 14 14:00:50 2018]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python-导包]]></title>
    <url>%2F2018%2F09%2F28%2Fpython%E6%A8%A1%E5%9D%97-%E5%AF%BC%E5%85%A5-%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[.py和.pyc文件++Python的程序中，是把原始程序代码放在.py文件里，而Python会在执行.py文件的时候。将.py形式的程序编译成中间式文件（byte-compiled）的.pyc文件，这么做的目的就是为了加快下次执行文件的速度。所以，在我们运行python文件的时候，就会自动首先查看是否具有.pyc文件，如果有的话，而且.py文件的修改时间和.pyc的修改时间一样，就会读取.pyc文件，否则，Python就会读原来的.py文件。其实并不是所有的.py文件在与运行的时候都会差生.pyc文件，只有在import相应的.py文件的时候，才会生成相应的.pyc文件，所以有时候为了一些隐秘可以将pyc文件给他人，这样源代码不会暴露++ 添加环境变量++export PYTHONPATH=$PYTHONPATH:/forum++++source /etc/profile++ sys.path import sys sys.pathsys.path指定用于模块搜索路径的字符串列表。它根据环境变量PYTHONPATH进行初始化，再加上安装时的默认值。 一次导入一个1234567891011121314&gt;&gt;&gt; import sushu as su 或者import sushu&gt;&gt;&gt; dir(su)[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;suhsu&apos;]&gt;&gt;&gt; su.suhsu()10 不是素数11 是素数&gt;&gt;&gt;从某个模块中导入某个函数，可以直接使用&gt;&gt;&gt; from os import chdir,listdir&gt;&gt;&gt; dir()[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;chdir&apos;, &apos;listdir&apos;, &apos;os&apos;, &apos;su&apos;]&gt;&gt;&gt; chdir(&apos;/var&apos;)&gt;&gt;&gt; 批量导入1import mod1.mod2,mod3 从zip文件中导入1234567891011121314151617181920[root@suiyuewuheng python]# zip test.zip ./test/* adding: test/add.py (deflated 21%) adding: test/sanjiao3.py (deflated 42%) adding: test/sanjiao.py (deflated 39%) adding: test/seekfile.py (deflated 39%) adding: test/shijian2.py (deflated 42%) adding: test/shijian.py (deflated 40%) adding: test/sushu.py (deflated 40%)&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/var/python/test.zip&apos;)&gt;&gt;&gt; import sushu&gt;&gt;&gt; dir(sushu)[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;suhsu&apos;]&gt;&gt;&gt; sushu.suhsu()10 不是素数11 是素数11 不是素数12 不是素数13 是素数 导入打包模块 不能自己导自己，也就是不能在函数中导入与该文件名相同的模块 先后导入的模块中如果包含相同的函数名，则函数以后者为准 123456789101112131415161718192021222324252627282930313233343536为了能够让python识别，每个目录下需要创建一个 __init.py__初始化文件结构如下:[root@suiyuewuheng /]# tree forum/forum/├── admin│ ├── __init__.py│ ├── __init__.pyc│ ├── post.py│ └── post.pyc├── guest│ ├── __init__.py│ └── sanjiao2.py├── __init__.py└── user ├── abc.py ├── abc.pyc ├── __init__.py └── __init__.pyc3 directories, 11 files[root@suiyuewuheng /]# [root@suiyuewuheng /]# python&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/forum&apos;)&gt;&gt;&gt;sys.path //查看路径是否已添加&gt;&gt;&gt; import forum.user.abc&gt;&gt;&gt; dir()[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;admin&apos;, &apos;os&apos;, &apos;post&apos;, &apos;sys&apos;, &apos;user&apos;]&gt;&gt;&gt; dir(user)[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__path__&apos;, &apos;abc&apos;]&gt;&gt;&gt; dir(user.abc)[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;rra&apos;]&gt;&gt;&gt; user.abc.rra() //调用rra()函数&apos;hello&apos; &gt;&gt;&gt; name main123__name__指的是当前文件的模块名当我们在函数中打印__name__变量时，print(__name__)，结果会输出__main__,而当我们在别的文件中调用该模块时，打印的__name__变量就变成了文件名，而不再是__main__，所以我们可以在原模块中添加一句if __name__ == &apos;__main__&apos;: 来进行判断，如果本地执行，则会执行后续代码，如果被调用，则条件不成立，不会执行后续代码，避免干扰]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python-循环]]></title>
    <url>%2F2018%2F09%2F28%2Fpython%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[for循环 for循环的语法格式如下:for iterating_var in sequence: statements(s) while循环 while循环基本形式为:while 判断条件： 执行语句…… 12执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。当判断条件假false时，循环结束。 if-else小案例:**注意，这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了 1234567891011121314151617181920212223242526272829#### 检测成绩vim grade.py#!/bin/bash score = int(raw_input(&apos;PLS input score: &apos;))if score &lt; 60 : print &quot;Failed&quot; //前面打上四个空格，控制格式 ，下同 elif score &gt;= 60 print &quot;Pass&quot; elif score &gt; 75 print &quot;Good&quot; else: print &quot;exclent&quot; 运行:[root@suiyuewuheng python]# python grage2.py PLS input score: 55Failed[root@suiyuewuheng python]# python grage2.py PLS input score: 89exclent#### 从小到大逆序:age = 54if age &lt;=6: print &apos;kid&apos;elif age &lt;=18: print &apos;teenager&apos;else: print &apos;adult&apos; continue continue 语句是一个删除的效果，他的存在是为了删除满足循环条件下的某些不需要的成分: 12345678910111213141516171819202122232425continue 语句是一个删除的效果，他的存在是为了删除满足循环条件下的某些不需要的成分:计算60分以上的和，使用continue&gt;&gt;&gt; L=[23,54,60,65,78,34,90]&gt;&gt;&gt; sum=0&gt;&gt;&gt; n=0&gt;&gt;&gt; for x in L:... if x&lt;60:... continue... sum=sum+x... n=n+1... &gt;&gt;&gt; print sum293计算1-100的奇数和，使用continuesum = 0x = 0while True: x = x + 1 if x &gt;100: break if x%2==0: continue sum=sum+xprint sum 用户信息1234567891011121314vim dic#!/usr/bin/python2s1 = &#123;&apos;name&apos;:&apos;jake&apos;,&apos;age&apos;:23,&apos;addr&apos;:&apos;xiangtan&apos;&#125;s2 = &#123;&apos;name&apos;:&apos;jak&apos;,&apos;age&apos;:23,&apos;addr&apos;:&apos;xiangtan&apos;&#125;s3 = &#123;&apos;name&apos;:&apos;ja&apos;,&apos;age&apos;:23,&apos;addr&apos;:&apos;xiangtan&apos;&#125;students = [s1,s2,s3]fam = [one for one in students if one[&apos;name&apos;]==&apos;ja&apos;]print fam运行:[root@suiyuewuheng python]# python dic[&#123;&apos;age&apos;: 23, &apos;name&apos;: &apos;ja&apos;, &apos;addr&apos;: &apos;xiangtan&apos;&#125;][root@suiyuewuheng python]# 打印金三角1234567891011#!/usr/bin/python2for i in range(1,5): print (&apos; &apos; * (5-i) + &apos;*&apos; *(2*i-1) )运行[root@suiyuewuheng python]# python sanjiao.py * *** ***** *******[root@suiyuewuheng python]# 123456while循环实现#!/usr/bin/python2i=1while i&lt;=5: print (&apos; &apos;*(5-i) + &apos;*&apos;*(2*i-1)) i+=1 123456倒三角#!/usr/bin/python2i=5while i&gt;=1: print (&apos; &apos;*(5-i) + &apos;*&apos;*(2*i-1)) i-=1 判断素数123456789#!/usr/bin/python2# -*- coding: utf-8 -*for i in range(10,20): for j in (2,i): if i%j==0: print i, &quot;不是素数&quot; break else: print i, &quot;是素数&quot; 打印对称数123print [a*100+b*10+c for a in range(1,10) for b in range(0,10) for c in range(1,10) if a==c]运行结果：[101, 111, 121, 131, 141, 151, 161, 171, 181, 191.....]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python-函数]]></title>
    <url>%2F2018%2F09%2F28%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数名其实就是指向函数的变量，指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名” 函数名其实就是指向函数的变量12345&gt;&gt;&gt; abs(-10)10&gt;&gt;&gt; b=abs&gt;&gt;&gt; b(-10)10 简化多行式123456789101112131415&gt;&gt;&gt; def add(x):... return x+x... &gt;&gt;&gt; alist = [1,2,3,4,5]&gt;&gt;&gt; temp = []&gt;&gt;&gt; for num in alist:... temp.append(add(num))... &gt;&gt;&gt; temp[2, 4, 6, 8, 10]&gt;&gt;&gt; temp2 = []&gt;&gt;&gt; temp2 = [add(num) for num in alist]&gt;&gt;&gt; temp2[2, 4, 6, 8, 10]&gt;&gt;&gt; 例子：求某个数的多次方12345678910&gt;&gt;&gt; def power(x,n):... s=1... while(n&gt;0):... n=n-1... s=s*x... return s... 运行：&gt;&gt;&gt; power(2,3)8&gt;&gt;&gt; 定义默认参数*tuple_args **dict_args12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def greet(a=&apos;world&apos;): print &apos;hello&apos;,a greet() greet(&apos;Bart&apos;)运行：hello worldhello Bart默认参数需在非默认参数之后&gt;&gt;&gt; def bar(x=87,y):... return x*y... File &quot;&lt;stdin&gt;&quot;, line 1SyntaxError: non-default argument follows default argument&gt;&gt;&gt; def bar(y,x=34):... return x*y... &gt;&gt;&gt; bar(10,23)230&gt;&gt;&gt;小案例:&gt;&gt;&gt; def reg(name,sex=&quot;male&quot;):... print &quot;%s is %s &quot; % (name,&quot;boy&quot; if sex == &apos;male&apos; else &quot;girl&quot;)... &gt;&gt;&gt; 运行：&gt;&gt;&gt; reg(&apos;xiao&apos;)xiao is boy &gt;&gt;&gt; 默认tuple参数&gt;&gt;&gt; def alist(*b):... total=0... for i in b:... total+=i... return total... &gt;&gt;&gt; alist(*blist)33默认字典参数&gt;&gt;&gt; def bar(**host):... return host[&apos;name&apos;]... &gt;&gt;&gt; host1=&#123;&apos;name&apos;:&apos;xiao&apos;&#125;&gt;&gt;&gt; bar(**host1)&apos;xiao&apos;&gt;&gt;&gt; 空函数如果想定义一个什么事也不做的空函数，可以用pass语句： 123456789def nop(): passpass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。pass还可以用在其他语句里，比如：if age &gt;= 18: pass缺少了pass，代码运行就会有语法错误。 lambda表达式123456789101112131415161718列表指定元素排序:&gt;&gt;&gt; a=[(10, 5), (3, 1), (4, 2), (8, 10)]&gt;&gt;&gt; a.sort(key=lambda x:x[1])&gt;&gt;&gt; a[(3, 1), (4, 2), (10, 5), (8, 10)]&gt;&gt;&gt; a.sort(key=lambda x:x[1],reverse=True)&gt;&gt;&gt; a[(8, 10), (10, 5), (4, 2), (3, 1)]&gt;&gt;&gt; a.sort(key=lambda x:x[0])&gt;&gt;&gt; a[(3, 1), (4, 2), (8, 10), (10, 5)]&gt;&gt;&gt; a.sort(key=lambda x:x[0],reverse=True)&gt;&gt;&gt; a[(10, 5), (8, 10), (4, 2), (3, 1)]&gt;&gt;&gt; 两列表综合输出大的元素&gt;&gt;&gt; map(lambda x,y:x if x&gt;y else y, list1, list2) 导入自己创建的库1234567891011121314151617181920212223242526272829303132333435363738&gt; 创建vim mytools.py#!/usr/bin/python2&quot;&quot;&quot; author:xiao descrption:this is a tools&quot;&quot;&quot;import timeimport osimport sysdef add(x,y): &apos;&apos;&apos;x: &lt;int&gt; number a y: &lt;int&gt; number b add(x,y) --&gt; sum of x and y &apos;&apos;&apos; return x+ydef sub(xy): return x-y &gt; 导入[root@suiyuewuheng ~]# pythonPython 2.7.5 (default, Nov 6 2016, 00:28:07) [GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import mytools&gt;&gt;&gt; dir(mytools)[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;add&apos;, &apos;os&apos;, &apos;sub&apos;, &apos;sys&apos;, &apos;time&apos;]&gt;&gt;&gt; help(mytools.add)Help on function add in module mytools:add(x, y) x: &lt;int&gt; number a y: &lt;int&gt; number b add(x,y) --&gt; sum of x and y(END) 异常处理 什么是异常？异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常异常是Python对象，表示一个错误。当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python#encoding:UTF-8try: fh=open(&quot;test.py&quot;) fh.write(&quot;测试异常!!&quot;)except: print &quot;测试有问题,执行下面语句&quot;print &quot;执行&quot;运行:[root@suiyuewuheng python]# python try.py 测试有问题,执行下面语句执行&gt; 因为没有写权限，所以写入失败，抛出异常，如果给予写权限，将会咋样？如下：修改文件，给予w权限#!/usr/bin/python#encoding:UTF-8try: fh=open(&quot;test.py&quot;,&apos;w&apos;) #需要判断是否会抛出异常的代码，如果没有异常处理，python会直接停止执行程序 fh.write(&quot;测试异常!!&quot;)except: #这里会捕捉到上面代码中的异常，并根据异常抛出异常处理信息 print &quot;测试有问题,执行下面语句&quot;print &quot;执行&quot; #如果没有异常则执行else&gt; 运行：[root@suiyuewuheng python]# python try.py 执行[root@suiyuewuheng python]# cat test.py 测试异常!!&gt; 正确输出，没有抛出异常，信息已写入文件//再来测试一个python类class Person(object): def __init__(self, name, score): self.name=name self.__score=scorep = Person(&apos;Bob&apos;, 59)print p.nametry: print p.__scoreexcept AttributeError: print &quot;attributeerror&quot;综上，我们可以看出，异常处理就是对程序的可执行的一种保护，使程序能依旧运行，不会因为异常错误而终止，但是不再执行异常错误里面后面的代码，而是异常块之外的代码，一句话：有异常抛出异常，继续运行异常块外程序，没有异常则不抛出异常，正确执行程序。 高阶函数 能接受函数做参数的函数 原理:变量可以指向函数–&gt;函数的参数可以接受变量–&gt;一个函数可以接受另一个函数作为参数–&gt;高阶函数12345678910111213&gt;&gt;&gt; def sub(f,x,y):... return f(x)+f(y)... &gt;&gt;&gt; sub(abs,-6,2)8再如:import mathdef add(x, y, f): return f(x) + f(y)print add(25, 9, math.sqrt)math.sqrt计算x的1/2次方 在python中返回函数12345678def calc_prod(lst): def jisun(): return reduce(lambda x,y:x*y,lst) return jisunf = calc_prod([1, 2, 3, 4]) //令f等于外层函数的返回值jisun，而jisuan是指向jisun()函数的变量，所以f()表示调用jisun()函数print f()运行结果:24 python中闭包 ++内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变，如上实例++ 将输入用户名格式化首字母大写，其余小写1234567891011def format_name(s): return s[0].upper()+s[1:].lower()print map(format_name, [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;])输出:[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]简化:&gt;&gt;&gt; map(lambda x:x[0].upper()+x[1:].lower(), [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;])输出:[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]也可以用函数 title() reduce()高阶内置函数reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。12345678910111213def prod(x, y): return x*yprint reduce(prod, [2, 4, 5, 7, 12])运行结果:3360 //列表所有有元素的乘积&gt;&gt;&gt; reduce(lambda x,y:x*y,[1,2,3,4,5])120求6的阶乘&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,7))720&gt;&gt;&gt; filter() filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; ages = [5, 12, 17, 18, 24, 32]&gt;&gt;&gt; adults = filter(lambda x:x&lt;18, ages)&gt;&gt;&gt; for x in adults:... print(x)... 51217&gt;&gt;&gt; 匹配出奇数&gt;&gt;&gt; a=filter(lambda x:x%2!=0, range(1,20))&gt;&gt;&gt; a[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]&gt;&gt;&gt; 匹配平方根是整数&gt;&gt;&gt; a=filter(lambda x:math.sqrt(x)%1==0,range(1,20))&gt;&gt;&gt; a[4, 16]查看某库以特定字符开头的函数&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;s&apos;),dir(&apos;&apos;)) [&apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;]&gt;&gt;&gt; import os&gt;&gt;&gt; import os.path&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;ch&apos;),dir(os)) [&apos;chdir&apos;, &apos;chmod&apos;, &apos;chown&apos;, &apos;chroot&apos;]&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;ch&apos;),dir(os.path)) []&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;get&apos;),dir(os.path)) [&apos;getatime&apos;, &apos;getctime&apos;, &apos;getmtime&apos;, &apos;getsize&apos;]&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;s&apos;),dir()) []&gt;&gt;&gt; filter(lambda fname:fname.startswith(&apos;s&apos;),dir(&apos;&apos;)) [&apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;]&gt;&gt;&gt; 递归函数 求某数的阶乘1234567891011&gt;&gt;&gt; def jie(x):... if x==1:... return 1... else:... return x*jie(x-1)... &gt;&gt;&gt; jie(4)24&gt;&gt;&gt; jie(6)720&gt;&gt;&gt; yield代替return123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; def jyg():... return 10... return 100... return 1000... &gt;&gt;&gt; jyg()10&gt;&gt;&gt; jyg()10使用yield代替return，取出下一个值&gt;&gt;&gt; def jyg():... yield 10... yield 100... &gt;&gt;&gt; jyg()&lt;generator object jyg at 0x7fa71cb8dc80&gt;使用next()去下一个结果每次取出一个结果&gt;&gt;&gt; def getnum():... while True:... yield random.randint(1,10)... &gt;&gt;&gt; getnum()&lt;generator object getnum at 0x7fa71cbabdc0&gt;&gt;&gt;&gt; getnum().next()9&gt;&gt;&gt; &gt;&gt;&gt; getnum().next()4&gt;&gt;&gt; getnum().next()3&gt;&gt;&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python物语-内置函数]]></title>
    <url>%2F2018%2F09%2F15%2Fpython%E7%89%A9%E8%AF%AD-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[a.find()截取特定字符串 find方法可以在一个较长的字符串中查找子字符串。它返回子串所在位置的最左端索引。如果没有找到则返回-11234567891011&gt;&gt;&gt; a = &apos;test&apos;&gt;&gt;&gt; a.find(&apos;s&apos;)2&gt;&gt;&gt;info = &apos;abca&apos;&gt;&gt;&gt; print info.find(&apos;a&apos;) # 从下标0开始，查找在字符串里第一个出现的子串，返回结果：00&gt;&gt;&gt; print info.find(&apos;a&apos;,1) # 从下标1开始，查找在字符串里第一个出现的子串：返回结果33&gt;&gt;&gt; print info.find(&apos;3&apos;) # 查找不到返回-1-1&gt;&gt;&gt; 截取某段字符串。12345&gt;&gt;&gt; a = &quot;i want my tears back&quot;&gt;&gt;&gt; b = a[a.find(&apos;w&apos;):a.find(&apos;s&apos;)]&gt;&gt;&gt; b&apos;want my tear&apos;&gt;&gt;&gt; join1234567891011121314151617181920212223242526272829join方法是非常重要的字符串方法，它是split方法的逆方法，用来在队列中添加元素。注意：需要添加的队列元素都必须是字符串。&gt;&gt;&gt; test = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]&gt;&gt;&gt; out = &apos;+&apos;.join(test)&gt;&gt;&gt; out&apos;a+b+c+d&apos;数字与字符转换&gt;&gt;&gt; blist=[random.randint(1,20) for i in range(10)]&gt;&gt;&gt; blist[3, 14, 1, 15, 16, 13, 9, 8, 10, 3]&gt;&gt;&gt; clist=[str(e) for e in blist] &gt;&gt;&gt; clist[&apos;3&apos;, &apos;14&apos;, &apos;1&apos;, &apos;15&apos;, &apos;16&apos;, &apos;13&apos;, &apos;9&apos;, &apos;8&apos;, &apos;10&apos;, &apos;3&apos;]&gt;&gt;&gt; &apos;&apos;.join(clist)&apos;314115161398103&apos;&gt;&gt;&gt; &apos;-&apos;.join(clist)&apos;3-14-1-15-16-13-9-8-10-3&apos;&gt;&gt;&gt; &apos;*&apos;.join(clist)&apos;3*14*1*15*16*13*9*8*10*3&apos;&gt;&gt;&gt; 浮点类型&gt;&gt;&gt; dlist=[1.2,12.3,4.0,5.5]&gt;&gt;&gt; elist=[ &apos;%.2f&apos; % e for e in dlist]&gt;&gt;&gt; elist[&apos;1.20&apos;, &apos;12.30&apos;, &apos;4.00&apos;, &apos;5.50&apos;]&gt;&gt;&gt; &apos;*&apos;.join(elist)&apos;1.20*12.30*4.00*5.50&apos;&gt;&gt;&gt; replace() replace方法返回某个字符串的所有匹配项均被替换之后得到的字符串。12345678910111213141516&gt;&gt;&gt; a = &apos;hello world&apos;&gt;&gt;&gt; b = a.replace(&apos;r&apos;,&apos;l&apos;)&gt;&gt;&gt; b&apos;hello wolld&apos;&gt;&gt;&gt;&gt;&gt;&gt; a&apos;dsaasdfa0&apos;&gt;&gt;&gt; b=a.replace(&apos;a&apos;,&apos;s&apos;,2)&gt;&gt;&gt; b&apos;dssssdfa0&apos;&gt;&gt;&gt; b=a.replace(&apos;a&apos;,&apos;s&apos;,1)&gt;&gt;&gt; b&apos;dssasdfa0&apos;&gt;&gt;&gt; 其中2,1表示替换字符不超过2,1次 len()123456&gt; 获取对象长度&gt;&gt;&gt; a = &apos;hello world&apos;&gt;&gt;&gt; b = len(a)&gt;&gt;&gt; b11&gt;&gt;&gt; 连接字符串123456&gt;&gt;&gt; a=&apos;dsfa&apos;&gt;&gt;&gt; b=&apos;&apos;&gt;&gt;&gt; c=&apos;sd&apos;&gt;&gt;&gt; a+b+c&apos;dsfasd&apos;&gt;&gt;&gt; cmp 比较字符串1234567891011121314151617&gt;&gt;&gt; a = &apos;hello&apos;&gt;&gt;&gt; b = &apos;world&apos;&gt;&gt;&gt; c = cmp(a,b)&gt;&gt;&gt; c-1&gt;&gt;&gt; cmp(&apos;a&apos;,&apos;A&apos;)1&gt;&gt;&gt; cmp(&apos;a&apos;,&apos;b&apos;)-1&gt;&gt;&gt; cmp(&apos;a&apos;,&apos;a&apos;)0&gt;&gt;&gt; ord(&apos;a&apos;) //返回字符对应的ASCII码97&gt;&gt;&gt; ord(&apos;A&apos;)65&gt;&gt;&gt; 前者小，返回-1，前者大，返回1，一样大，返回0 random123456789101112131415161718192021222324252627&gt;&gt;&gt; import random&gt;&gt;&gt; blist=[random.randint(1,20) for i in range(10)]&gt;&gt;&gt; blist[3, 14, 1, 15, 16, 13, 9, 8, 10, 3]&gt;&gt;&gt; 数字字符串转换&gt;&gt;&gt; blist=[random.randint(1,20) for i in range(10)]&gt;&gt;&gt; blist[3, 14, 1, 15, 16, 13, 9, 8, 10, 3]&gt;&gt;&gt; clist=[str(e) for e in blist] &gt;&gt;&gt; clist[&apos;3&apos;, &apos;14&apos;, &apos;1&apos;, &apos;15&apos;, &apos;16&apos;, &apos;13&apos;, &apos;9&apos;, &apos;8&apos;, &apos;10&apos;, &apos;3&apos;]&gt;&gt;&gt; &apos;&apos;.join(clist)&apos;314115161398103&apos;&gt;&gt;&gt; &apos;-&apos;.join(clist)&apos;3-14-1-15-16-13-9-8-10-3&apos;&gt;&gt;&gt; &apos;*&apos;.join(clist)&apos;3*14*1*15*16*13*9*8*10*3&apos;&gt;&gt;&gt; 浮点类型&gt;&gt;&gt; dlist=[1.2,12.3,4.0,5.5&gt;&gt;&gt; elist=[ &apos;%.2f&apos; % e for e in dlist]&gt;&gt;&gt; elist[&apos;1.20&apos;, &apos;12.30&apos;, &apos;4.00&apos;, &apos;5.50&apos;]&gt;&gt;&gt; &apos;*&apos;.join(elist)&apos;1.20*12.30*4.00*5.50&apos;&gt;&gt;&gt; enumerate()enumnrate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。1234&gt;&gt;&gt; seasons = [&apos;Spring&apos;, &apos;Summer&apos;, &apos;Fall&apos;, &apos;Winter&apos;]&gt;&gt;&gt; list(enumerate(seasons))[(0, &apos;Spring&apos;), (1, &apos;Summer&apos;), (2, &apos;Fall&apos;), (3, &apos;Winter&apos;)]&gt;&gt;&gt; sorted() max() min() sum()12345678910111213&gt;&gt;&gt; tmplist[6, 19, 1, 19, 16, 1, 15, 7, 1, 18]&gt;&gt;&gt; max(tmplist)19&gt;&gt;&gt; min(tmplist)1&gt;&gt;&gt; sorted(tmplist)[1, 1, 1, 6, 7, 15, 16, 18, 19, 19]&gt;&gt;&gt; sorted(tmplist,reverse=True)[19, 19, 18, 16, 15, 7, 6, 1, 1, 1]&gt;&gt;&gt;&gt; 计算平均值sum(tmplist) / len(tmplist) zip zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。123456789101112131415161718192021&gt;&gt;&gt; aalist=[1,2,3,4]&gt;&gt;&gt; bblist=[5,6,7,8]&gt;&gt;&gt; zip(aalist,bblist)[(1, 5), (2, 6), (3, 7), (4, 8)]&gt;&gt;&gt; bblist=[5,6,7]&gt;&gt;&gt; zip(aalist,bblist)[(1, 5), (2, 6), (3, 7)]&gt;&gt;&gt; &gt;&gt;&gt; aalist=[1,2,3,4,5,6]&gt;&gt;&gt; zip(aalist[:-1],aalist[1:])[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]&gt;&gt;&gt; 转矩阵&gt;&gt;&gt; a=[1,2,3]&gt;&gt;&gt; b=[4,5,6]&gt;&gt;&gt; c=zip(a,b)&gt;&gt;&gt; c[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(*c)[(1, 2, 3), (4, 5, 6)]&gt;&gt;&gt; strip() Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。123456789101112131415&gt;&gt;&gt; &apos; hahaha &apos;&apos; hahaha &apos;&gt;&gt;&gt; &apos; hahaha &apos;.strip() //去除首尾空格&apos;hahaha&apos;&gt;&gt;&gt; &apos; hahaha &apos;.rstrip() //去除尾部空格&apos; hahaha&apos;&gt;&gt;&gt; &apos; hahaha &apos;.lstrip() //去除头部空格&apos;hahaha &apos;&gt;&gt;&gt; &gt;&gt;&gt; str=&apos;hello&apos;&gt;&gt;&gt; str.strip(&apos;o&apos;)&apos;hell&apos;&gt;&gt;&gt; str.strip(&apos;h&apos;)&apos;ello&apos;&gt;&gt;&gt; upper() lower()123456&gt; 大小写转换&gt;&gt;&gt; &apos;suiyue&apos;.upper()&apos;SUIYUE&apos;&gt;&gt;&gt; &apos;suiyue&apos;.lower()&apos;suiyue&apos;&gt;&gt;&gt; center()dir(‘’)help(‘’.center) //查看帮助123456789打印菱形#!/usr/bin/python2for i in range(1,5): print &quot;\n&quot;, print (&apos;* &apos; * (2 * i - 1)).center(39)for i in range(5,0,-1): print &quot;\n&quot;, print (&apos;* &apos; * (2*i-1)).center(39) bool()12345678910&gt;&gt;&gt; &gt;&gt;&gt; bool(-1)True&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(0.0)False&gt;&gt;&gt; split() splitlines()12345678910split()切割字符串&gt;&gt;&gt; str=&quot;root:passwd:3234:fdfa refg:ewfs&quot;&gt;&gt;&gt; str.split();[&apos;root:passwd:3234:fdfa&apos;, &apos;refg:ewfs&apos;]&gt;&gt;&gt; str.split(&apos;:&apos;);[&apos;root&apos;, &apos;passwd&apos;, &apos;3234&apos;, &apos;fdfa refg&apos;, &apos;ewfs&apos;]&gt;&gt;&gt; str.split(&apos;:&apos;,2); [&apos;root&apos;, &apos;passwd&apos;, &apos;3234:fdfa refg:ewfs&apos;]&gt;&gt;&gt; splitlines()切割语句 swapcase()交换大小写1234&gt;&gt;&gt; b=&apos;fasdf&apos;&gt;&gt;&gt; b.swapcase()&apos;FASDF&apos;&gt;&gt;&gt; map()1234567891011121314151617&gt; map() 会根据提供的函数对指定序列做映射。第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。 &gt;&gt;&gt; map(square, [1,2,3,4,5]) # 计算列表各个元素的平方[1, 4, 9, 16, 25]&gt;&gt;&gt; map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数[1, 4, 9, 16, 25]使源数据增加一点五倍&gt;&gt;&gt; results=map((lambda x+(0.5*x)),[1,2,3,4]) File &quot;&lt;stdin&gt;&quot;, line 1 results=map((lambda x+(0.5*x)),[1,2,3,4]) ^SyntaxError: invalid syntax&gt;&gt;&gt; results=map((lambda x:x+(0.5*x)),[1,2,3,4])&gt;&gt;&gt; results[1.5, 3.0, 4.5, 6.0]&gt;&gt;&gt; set() 去除列表重复元素12345678910111213141516171819202122232425&gt;&gt;&gt; a=[&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;a&apos;,&apos;c&apos;,&apos;b&apos;]&gt;&gt;&gt; b=list(set(a))&gt;&gt;&gt; b[&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;d&apos;]###### 顺序不变&gt;&gt;&gt; b.sort(key=a.index)&gt;&gt;&gt; b[&apos;a&apos;, &apos;b&apos;, &apos;d&apos;, &apos;c&apos;]&gt;&gt;&gt; #### 查看重复元素&gt;&gt;&gt; a=[&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;a&apos;,&apos;c&apos;,&apos;b&apos;]&gt;&gt;&gt; b=set(a)&gt;&gt;&gt; bset([&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;d&apos;])&gt;&gt;&gt; for i in b:... print &quot;the %s is found %d&quot; %(i,a.count(i))... the a is found 2the c is found 1the b is found 2the d is found 1&gt;&gt;&gt; pop()方法123456789101112131415&gt; pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值,原列表缩短&gt;&gt;&gt; b[&apos;user1&apos;, &apos;user2&apos;, &apos;user3&apos;, &apos;user5&apos;, &apos;user6&apos;, &apos;user7&apos;, &apos;user8&apos;, &apos;user9&apos;, &apos;user10&apos;, &apos;user11&apos;, &apos;user12&apos;, &apos;user13&apos;, &apos;user14&apos;, &apos;user15&apos;, &apos;user16&apos;, &apos;user17&apos;, &apos;user18&apos;, &apos;user19&apos;, &apos;user20&apos;, &apos;user21&apos;, &apos;user22&apos;, &apos;user23&apos;, &apos;user24&apos;, &apos;user25&apos;, &apos;user26&apos;, &apos;user27&apos;, &apos;user28&apos;, &apos;user29&apos;, &apos;user30&apos;, &apos;user31&apos;, &apos;user32&apos;, &apos;user33&apos;, &apos;user34&apos;, &apos;user35&apos;, &apos;user36&apos;, &apos;user37&apos;, &apos;user38&apos;, &apos;user39&apos;, &apos;user40&apos;]&gt;&gt;&gt; len(b)39&gt;&gt;&gt; for i in range(3):... b.pop()... &apos;user40&apos;&apos;user39&apos;&apos;user38&apos;&gt;&gt;&gt; len(b)36&gt;&gt;&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python变量]]></title>
    <url>%2F2018%2F09%2F11%2Fpython%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[在内存中存储的数据可以有多种类型，Python有五个标准的数据类型： Numbers(数字) String（字符串） List（列表） Tuple（元组） Dictionary（字典） 其中属于集合类型的数据类型有 列表、元组及字典 变量赋值 Python 中的变量赋值不需要类型声明每个变量在内存中创建，都包括变量的标识，名称和数据这些信息，每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。等号（=）用来给变量赋值，等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值** 多个变量赋值Python允许你同时为多个变量赋值。 例如：a = b = c = 1以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。也可以为多个对象指定多个变量。 例如：a, b, c = 1, 2, “john”以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。 Python数字四种不同的数字类型： int（有符号整型） long（长整型[也可以代表八进制和十六进制]） float（浮点型） complex（复数） 下面详细介绍 int（整型）在32位机器上，整数的位数为32位，取值范围为-231～231-1，即-2147483648～2147483647 在64位系统上，整数的位数为64位，取值范围为-263～263-1，即-9223372036854775808～9223372036854775807 long（长整型）跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，长整数数值不可能无限大。 ++注意，自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了++ *float（浮点型）浮点数用来处理实数，即带有小数的数字。类似于C语言中的double类型，占8个字节（64位），其中52位表示底，11位表示指数，剩下的一位表示符号。 complex（复数）复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数。 加减乘除123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; num = 1&gt;&gt;&gt; print num1&gt;&gt;&gt; num = 345.3453&gt;&gt;&gt; print &quot;num is %d&quot; % numnum is 345&gt;&gt;&gt; print &quot;num is %f&quot; % numnum is 345.345300&gt;&gt;&gt; print &quot;num is %.2f&quot; % numnum is 345.35&gt;&gt;&gt; print &quot;num is %.4f&quot; % numnum is 345.3453&gt;&gt;&gt; num1 = 34&gt;&gt;&gt; num / 2172.67265&gt;&gt;&gt; num1 / 217&gt;&gt;&gt; num = 34&gt;&gt;&gt; num / 311&gt;&gt;&gt; num / 3.011.333333333333334&gt;&gt;&gt; 34 ** 23167500108222301408246337399112597504L&gt;&gt;&gt; 34 - 56-22&gt;&gt;&gt; del num&gt;&gt;&gt; del num1浮点数精确计算&gt;&gt;&gt;from decimal import Decimal&gt;&gt;&gt;a = Decimal(&apos;3.2&apos;)&gt;&gt;&gt;b = Decimal(&apos;2.1&apos;)&gt;&gt;&gt;print(a + b) 进制转换 十进制转二进制 123&gt;&gt;&gt; bin(22) &apos;0b10110&apos;&gt;&gt;&gt; bin 十进制转十六进制 12&gt;&gt;&gt; hex(345) &apos;0x159&apos; 二进制，十六进制转十进制 1234&gt;&gt;&gt;int(&apos;1010111&apos;,2) 174&gt;&gt;&gt; int(&apos;0xf&apos;,16) 15 二进制转十六进制和十六进制转二进制 1234567&gt;&gt;&gt; hex(int(&apos;1010111&apos;,2))&apos;0x57&apos;&gt;&gt;&gt;&gt;&gt;&gt; bin(int(&apos;ff&apos;,16))&apos;0b11111111&apos;&gt;&gt;&gt; Python字符串字符串或串(String)是由数字、字母、下划线组成的一串字符python的字串列表有2种取值顺序: 从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头 从字符串中获取一段子字符串，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 截取字符串：注意：一定要搞清楚下标是从0开始的，列表右边的元素是不被包含的，而且字符串打印方向默认从左向右，跳数为负则表示向左。 12345678910111213141516171819202122&gt;&gt;&gt; astr = &quot;abcdefg&quot;&gt;&gt;&gt; astr[:]&apos;abcdefg&apos;&gt;&gt;&gt; astr[2]&apos;c&apos;&gt;&gt;&gt; astr[0:6]&apos;abcdef&apos;&gt;&gt;&gt; astr = &quot;abcdefgh&quot;&gt;&gt;&gt; astr&apos;abcdefgh&apos;&gt;&gt;&gt; astr[2]&apos;c&apos;&gt;&gt;&gt; astr[2:6]&apos;cdef&apos;&gt;&gt;&gt; astr[2:]&apos;cdefgh&apos;&gt;&gt;&gt; print astr *4abcdefghabcdefghabcdefghabcdefgh&gt;&gt;&gt; print astr + &quot;!!hello&quot;abcdefgh!!hello&gt;&gt;&gt; print [astr] * 2[&apos;abcdefgh&apos;, &apos;abcdefgh&apos;] 1234567891011121314151617181920212223&gt;&gt;&gt; astr = &apos;123456789&apos;&gt;&gt;&gt; astr[0:2]&apos;12&apos;&gt;&gt;&gt; astr[0::2]&apos;13579&apos;&gt;&gt;&gt; astr[1::2]&apos;2468&apos;&gt;&gt;&gt; astr[::-1]&apos;987654321&apos;&gt;&gt;&gt; astr[1::-1]&apos;21&apos;&gt;&gt;&gt; astr[4::-1]&apos;54321&apos;&gt;&gt;&gt; astr[::]&apos;123456789&apos;&gt;&gt;&gt; astr[::1]&apos;123456789&apos;&gt;&gt;&gt; astr[::3]&apos;147&apos;&gt;&gt;&gt; astr[0::3]&apos;147&apos;&gt;&gt;&gt; astr[1::3]&apos;258&apos; 以上综述：123451. astr[1::-1] 表示打印下标1到下标0的元素,-1表示的是跳数1. astr[::-1] 表示逆序打印所有元素1. astr[0::-1] 表示打印下标0的元素1. astr[-5::2] 表示从倒数第5个开始，向右每隔一个元素打印2. satr[-2::-2] 表示从倒数第二个元素开始，向左每隔一个元素打印一个 Python列表 List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用 [ ] 标识，是 python 最通用的复合数据类型。列表中值的切割也可以用到变量[头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。 列表简单操作 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; list = [&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; tinylist = [&apos;world&apos;, 567]&gt;&gt;&gt; print list[&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; print (&quot;list&quot;)list&gt;&gt;&gt; list = [&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; print (&quot;list&quot;)list&gt;&gt;&gt; list = [&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; tinylist = [&apos;world&apos;, 567]&gt;&gt;&gt; print (list)[&apos;hello&apos;, &apos;tom&apos;, &apos;wel&apos;, 999]&gt;&gt;&gt; print (list[2])wel&gt;&gt;&gt; print (list[0:2])[&apos;hello&apos;, &apos;tom&apos;]&gt;&gt;&gt; print (list[::-1])[999, &apos;wel&apos;, &apos;tom&apos;, &apos;hello&apos;]&gt;&gt;&gt; print (list[2::-1])[&apos;wel&apos;, &apos;tom&apos;, &apos;hello&apos;]&gt;&gt;&gt; print (list[3::-1])[999, &apos;wel&apos;, &apos;tom&apos;, &apos;hello&apos;]&gt;&gt;&gt; print (list[::2])[&apos;hello&apos;, &apos;wel&apos;]&gt;&gt;&gt; print (list[::3])[&apos;hello&apos;, 999]&gt;&gt;&gt; print (list[1::2])[&apos;tom&apos;, 999] 生成列表快速方法：1234&gt;&gt;&gt; pystr=&apos;python&apos;&gt;&gt;&gt; list(pystr)[&apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]&gt;&gt;&gt; Python元组 元组是另一个数据类型，类似于List（列表）。元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; tuple(&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[1]786&gt;&gt;&gt; tuple[1::2](786, &apos;john&apos;)&gt;&gt;&gt; tuple[0::2](&apos;runoob&apos;, 2.23, 70.2)&gt;&gt;&gt; tuple[-4::1] 表示打印下标从-4到1的元素(786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[-4::-1] 表示打印下标从-4到-5的元素，-1不仅表示跳数，还表示打印方向从右向左(786, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-1::-2] 表示打印下标从-1到-5并且跳2个元素(70.2, 2.23, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-1::-1](70.2, &apos;john&apos;, 2.23, 786, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-5::] (&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[-5::-2] (&apos;runoob&apos;,)&gt;&gt;&gt; tuple[-5::-1](&apos;runoob&apos;,)&gt;&gt;&gt; tuple[-1:-4:-1] 表示打印下标从-1到-4挨个打印的元素，是逆序(70.2, &apos;john&apos;, 2.23)&gt;&gt;&gt; tuple[-5::](&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)&gt;&gt;&gt; tuple[-5::2](&apos;runoob&apos;, 2.23, 70.2)&gt;&gt;&gt; tuple[-3::-1](2.23, 786, &apos;runoob&apos;)&gt;&gt;&gt; tuple[-3::1](2.23, &apos;john&apos;, 70.2) Python 字典 字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 字典简单操作 1234567891011121314&gt;&gt;&gt; dict = &#123;&#125;&gt;&gt;&gt; dict[&apos;one&apos;] = &quot;this is one&quot;&gt;&gt;&gt; dict[2] = &quot;this is two&quot;&gt;&gt;&gt; print dict[&apos;one&apos;]this is one&gt;&gt;&gt; print dict[2]this is two&gt;&gt;&gt; dict1 = &#123;&apos;name&apos;: &apos;xiao&apos;,&apos;age&apos;: &apos;22&apos;,&apos;dept&apos;: &apos;sales&apos;&#125;&gt;&gt;&gt; print dict1&#123;&apos;dept&apos;: &apos;sales&apos;, &apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;xiao&apos;&#125;&gt;&gt;&gt; print dict1.keys()[&apos;dept&apos;, &apos;age&apos;, &apos;name&apos;]&gt;&gt;&gt; print dict1.values()[&apos;sales&apos;, &apos;22&apos;, &apos;xiao&apos;] raw_input() raw_input函数，用来获取控制台的输入，并且将所有输入看做字符串，返回字符串类型 123456789101112131415编辑脚本 hello.py vim hello.py #!/usr/bin/python2name = raw_input(&apos;PLS input your usernmae: &apos;) age = raw_input(&apos;PLS input your age: &apos;) print &quot; you name %s you are %d age&quot; % (name,int(age))运行测试[root@suiyuewuheng python]# python hello.py PLS input your usernmae: xiaoPLS input your age: 22 you name xiao you are 22 age[root@suiyuewuheng python]# 这里要记得将age变量类型进项转换，不然会报语法错误 结合列表作个测试： 123456789101112&gt;&gt;&gt; list1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,raw_input] &gt;&gt;&gt; list[-1] 999 &gt;&gt;&gt; list1[-1] &lt;built-in function raw_input&gt; &gt;&gt;&gt; list1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,raw_input] &gt;&gt;&gt; list1[-1] &lt;built-in function raw_input&gt; &gt;&gt;&gt; list1[-1](&apos;pls input your passwd: &apos;) pls input your passwd: redhat &apos;redhat&apos; &gt;&gt;&gt; Python变量++ 注意python中有可变对象和不可变对象，可变对象：list,dict.不可变对象有:int,string,float,tuple。 不可变对象类型：有i和j俩个变量的值为77，通过打印77的ID和变量i，j在内存中的id我们得知它们都是指向同一块内存。所以说i和j都是指向同一个对象的。然后我们修改j的值，让j的值+1.按道理j修改之后应该i的值也发生改变的，因为它们都是指向的同一块内存，但结果是并没有。因为int类型是不可变类型，所有其实是j复制了一份到新的内存地址然后+1，然后j又指向了新的地址。所以j的内存id发生了变化。123456789&gt;&gt;&gt; def add(num):... num=num+1... return num... &gt;&gt;&gt; a=1&gt;&gt;&gt; add(a)2&gt;&gt;&gt; print a1 可变对象类型123456789101112131415161718192021测试：def dict_test(): a = &#123;&#125; b = a print(id(a)) a[&apos;a&apos;] = &apos;hhhh&apos; print(&apos;id a:&apos; + str(id(a))) print(&apos;a:&apos; + str(a)) print(&apos;id b:&apos; + str(id(b))) print(&apos;b:&apos; + str(b)) 运行结果：140367329543360id a:140367329543360a:&#123;&apos;a&apos;: &apos;hhhh&apos;&#125;id b:140367329543360b:&#123;&apos;a&apos;: &apos;hhhh&apos;&#125; 可以看到a最早的内存地址id是140367329543360 然后把a赋值给b其实就是让变量b的也指向a所指向的内存空间。然后我们发现当a发生变化后，b也跟着发生变化了，因为list是可变类型，所以并不会复制一份再改变，而是直接在a所指向的内存空间修改数据，而b也是指向该内存空间的，自然b也就跟着改变了。 在 python 中，类型属于对象，变量是没有类型的：a=[1,2,3]a=”Runoob”以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。 全局变量与局部变量123456789101112131415161718&gt; 局部变量:#!/usr/bin/python2#encoding:utf-8x=12def func(x): print &quot;全局x=&quot; ,x x=1 print &quot;局部x=&quot; ,xfunc(x)print &quot;全局x=&quot; ,x运行结果:[root@suiyuewuheng python]# python jubu.py 全局x= 12局部x= 1全局x= 12[root@suiyuewuheng python]# 1234567891011121314151617181920&gt; 全局变量#!/usr/bin/python2#encoding:utf-8x=12def func(): global x //声明是全局变量 print &quot;全局x=&quot; ,x x=1 print &quot;局部x=&quot; ,xfunc()print &quot;全局x=&quot; ,x&gt; 运行结果:[root@suiyuewuheng python]# vim jubu.py [root@suiyuewuheng python]# python jubu.py 全局x= 12局部x= 1全局x= 1]]></content>
  </entry>
  <entry>
    <title><![CDATA[软链接与硬链接]]></title>
    <url>%2F2018%2F09%2F10%2F%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[概述 在Linux系统中,内核为每一个新创建的文件分配一个Inode(索引结点),每个文件都有一个惟一的inode号。文件属性保存在索引结点里，在访问文件时，索引结点被复制到内存在，从而实现文件的快速访问。链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的一种方法。Linux中包括两种链接：硬链接(Hard Link)和软链接(Soft Link),软链接又称为符号链接（Symbolic link）。符号连接相当于Windows下的快捷方式。 硬链接 语法： ln src-file dst-file 硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。可以用:ln命令来建立硬链接 123456789101112131415mkdir new &amp;&amp; echo &quot;this is new file&quot; &gt; new/own.filecd /newln own.file &gt; hardls -l[root@suiyuewuheng new]# ls -ltotal 8-rw-r--r-- 2 root root 17 Sep 10 11:27 hard-rw-r--r-- 2 root root 17 Sep 10 11:27 own.file[root@suiyuewuheng new]# cat hard this is new file[root@suiyuewuheng new]# rm -rf *[root@suiyuewuheng new]# mkdir file.dr[root@suiyuewuheng new]# ln file.dir file.dir.handln: failed to access ‘file.dir’: No such file or directory[root@suiyuewuheng new]# 从上我们可以看到，两个文件有相同的inode值和文件属性，它们指向的都是同一个区块，查看文件内容，两个文件也一模一样，说白了硬链接是一个指针，指向文件索引节点，系统并不为它重新分配inode，建立file的硬链接就是为file的文件索引节点在当前目录上建立一个新指针，删除其中任何一个文件，链接数会减一，当所有链接文件都被删除时（也就是当链接数减到零时），文件就会从磁盘上删除 硬链接不足： 不可以在不同文件系统的文件间建立链接 只有超级用户才可以为目录创建硬链接 不能为目录创建硬链接 软链接 语法：ls -s src.file dst.file 软链接类似windows下的快捷方式，它实际上是一个特殊的文件，在软连接中，软连接文件实际上就是一个文本文件，这个文件中包含有软链接指向另一个文件的文职信息内容，因此，通过访问这个“快捷方式”就可以迅速定位到软链接所指向的源文件实体。 12345678910111213[root@suiyuewuheng new]# touch file1[root@suiyuewuheng new]# ln -s file1 file1.soft[root@suiyuewuheng new]# mkdir file1.dir[root@suiyuewuheng new]# ln -s file1.dir file1.dir.soft[root@suiyuewuheng new]# ln file1.dir file1.dir.handln: ‘file1.dir’: hard link not allowed for directory[root@suiyuewuheng new]# ls -litotal 42490370 -rw-r--r-- 1 root root 0 Sep 10 12:22 file12490372 drwxr-xr-x 2 root root 4096 Sep 10 12:22 file1.dir2490373 lrwxrwxrwx 1 root root 9 Sep 10 12:23 file1.dir.soft -&gt; file1.dir2490371 lrwxrwxrwx 1 root root 5 Sep 10 12:22 file1.soft -&gt; file1[root@suiyuewuheng new]# 可以看到，软链接具有和源文件不同的inode节点值，它们是不同的文件，在文件属性上软链接明确写出了是链接文件，而硬链接没有写出来，因为在本质上硬链接文件和原文件是完全平等关系，第三列是文件链接数或者目录子目录数，file1.dir的目录子目录数没有增加，还是2，这个表示该目录下有两个子目录. 和 .. ,file1的文件链接数也咩有增加，第六列是文件大小，也不相同，file1是0B，而file1.soft是5B，这里的5B其实就是file1的大小，软链接可以指向目录，而硬链接不能指向目录。当删除源文件时，软链接文件随即消失。 总之，建立软链接就是建立了一个新文件。当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。 - [ ] 软链接不足 移动源文件，可能会导致软链接文件失效，无法找到源文件 消耗系统inode节点数和分配路径所需空间]]></content>
  </entry>
</search>
